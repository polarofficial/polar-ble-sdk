// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.1.2 (swiftlang-1100.0.278 clang-1100.0.33.9)
// swift-module-flags: -target i386-apple-watchos3.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RxCocoa
import CoreGraphics
import Dispatch
import Foundation
import Foundation/*.Data*/
import Foundation/*.Date*/
import Foundation/*.HTTPURLResponse*/
import Foundation/*.IndexPath*/
import Foundation/*.JSONSerialization*/
import Foundation/*.NSError*/
import Foundation/*.NSNull*/
import Foundation/*.NSNumber*/
import Foundation/*.NSObject*/
import Foundation/*.NSURLErrorCancelled*/
import Foundation/*.NSURLErrorDomain*/
import Foundation/*.NSValue*/
import Foundation/*.Notification*/
import Foundation/*.NotificationCenter*/
import Foundation/*.TimeInterval*/
import Foundation/*.URL*/
import Foundation/*.URLRequest*/
import Foundation/*.URLResponse*/
import Foundation/*.URLSession*/
import Foundation/*.arc4random*/
import Foundation/*.objc_getAssociatedObject*/
import Foundation/*.objc_setAssociatedObject*/
import Foundation.NSObject
@_exported import RxCocoa
@_exported import RxRelay
import RxSwift
import Swift
import UIKit
public struct Logging {
  public typealias LogURLRequest = (Foundation.URLRequest) -> Swift.Bool
  public static var URLRequests: RxCocoa.Logging.LogURLRequest
}
public protocol DelegateProxyType : AnyObject {
  associatedtype ParentObject : AnyObject
  associatedtype Delegate
  static func registerKnownImplementations()
  static var identifier: Swift.UnsafeRawPointer { get }
  static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
  func forwardToDelegate() -> Self.Delegate?
  func setForwardToDelegate(_ forwardToDelegate: Self.Delegate?, retainDelegate: Swift.Bool)
}
extension DelegateProxyType {
  public static var identifier: Swift.UnsafeRawPointer {
    get
  }
}
extension DelegateProxyType {
  public static func register<Parent>(make: @escaping (Parent) -> Self)
  public static func createProxy(for object: Swift.AnyObject) -> Self
  public static func proxy(for object: Self.ParentObject) -> Self
  public static func installForwardDelegate(_ forwardDelegate: Self.Delegate, retainDelegate: Swift.Bool, onProxyForObject object: Self.ParentObject) -> RxSwift.Disposable
}
public protocol HasDelegate : AnyObject {
  associatedtype Delegate
  var delegate: Self.Delegate? { get set }
}
extension DelegateProxyType where Self.Delegate == Self.ParentObject.Delegate, Self.ParentObject : RxCocoa.HasDelegate {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
public protocol HasDataSource : AnyObject {
  associatedtype DataSource
  var dataSource: Self.DataSource? { get set }
}
extension DelegateProxyType where Self.Delegate == Self.ParentObject.DataSource, Self.ParentObject : RxCocoa.HasDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
@available(iOS 10.0, tvOS 10.0, *)
public protocol HasPrefetchDataSource : AnyObject {
  associatedtype PrefetchDataSource
  var prefetchDataSource: Self.PrefetchDataSource? { get set }
}
@available(iOS 10.0, tvOS 10.0, *)
extension DelegateProxyType where Self.Delegate == Self.ParentObject.PrefetchDataSource, Self.ParentObject : RxCocoa.HasPrefetchDataSource {
  public static func currentDelegate(for object: Self.ParentObject) -> Self.Delegate?
  public static func setCurrentDelegate(_ delegate: Self.Delegate?, to object: Self.ParentObject)
}
extension BehaviorRelay {
  final public func asDriver() -> RxCocoa.Driver<Element>
}
public enum SharingScheduler {
  public static var make: () -> RxSwift.SchedulerType {
    get
    }
  public static func mock(scheduler: RxSwift.SchedulerType, action: () -> Swift.Void)
  public static func mock(makeScheduler: @escaping () -> RxSwift.SchedulerType, action: () -> Swift.Void)
}
public typealias Driver<Element> = RxCocoa.SharedSequence<RxCocoa.DriverSharingStrategy, Element>
public struct DriverSharingStrategy : RxCocoa.SharingStrategyProtocol {
  public static var scheduler: RxSwift.SchedulerType {
    get
  }
  public static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  public func asDriver() -> RxCocoa.Driver<Self.Element>
}
extension ObservableConvertibleType {
  public func asSignal(onErrorJustReturn: Self.Element) -> RxCocoa.Signal<Self.Element>
  public func asSignal(onErrorSignalWith: RxCocoa.Signal<Self.Element>) -> RxCocoa.Signal<Self.Element>
  public func asSignal(onErrorRecover: @escaping (Swift.Error) -> RxCocoa.Signal<Self.Element>) -> RxCocoa.Signal<Self.Element>
}
public protocol ControlEventType : RxSwift.ObservableType {
  func asControlEvent() -> RxCocoa.ControlEvent<Self.Element>
}
public struct ControlEvent<PropertyType> : RxCocoa.ControlEventType {
  public typealias Element = PropertyType
  public init<Ev>(events: Ev) where PropertyType == Ev.Element, Ev : RxSwift.ObservableType
  public func subscribe<Observer>(_ observer: Observer) -> RxSwift.Disposable where PropertyType == Observer.Element, Observer : RxSwift.ObserverType
  public func asObservable() -> RxSwift.Observable<RxCocoa.ControlEvent<PropertyType>.Element>
  public func asControlEvent() -> RxCocoa.ControlEvent<RxCocoa.ControlEvent<PropertyType>.Element>
}
extension ControlEvent {
  public func asSignal() -> RxCocoa.Signal<RxCocoa.ControlEvent<PropertyType>.Element>
}
public struct Binder<Value> : RxSwift.ObserverType {
  public typealias Element = Value
  public init<Target>(_ target: Target, scheduler: RxSwift.ImmediateSchedulerType = MainScheduler(), binding: @escaping (Target, Value) -> Swift.Void) where Target : AnyObject
  public func on(_ event: RxSwift.Event<Value>)
  public func asObserver() -> RxSwift.AnyObserver<Value>
}
public protocol SectionedViewDataSourceType {
  func model(at indexPath: Foundation.IndexPath) throws -> Any
}
public enum RxCocoaInterceptionMechanism {
  case unknown
  case kvo
  public static func == (a: RxCocoa.RxCocoaInterceptionMechanism, b: RxCocoa.RxCocoaInterceptionMechanism) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
}
public enum RxCocoaObjCRuntimeError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown(target: Swift.AnyObject)
  case objectMessagesAlreadyBeingIntercepted(target: Swift.AnyObject, interceptionMechanism: RxCocoa.RxCocoaInterceptionMechanism)
  case selectorNotImplemented(target: Swift.AnyObject)
  case cantInterceptCoreFoundationTollFreeBridgedObjects(target: Swift.AnyObject)
  case threadingCollisionWithOtherInterceptionMechanism(target: Swift.AnyObject)
  case savingOriginalForwardingMethodFailed(target: Swift.AnyObject)
  case replacingMethodWithForwardingImplementation(target: Swift.AnyObject)
  case observingPerformanceSensitiveMessages(target: Swift.AnyObject)
  case observingMessagesWithUnsupportedReturnType(target: Swift.AnyObject)
}
extension RxCocoaObjCRuntimeError {
  public var debugDescription: Swift.String {
    get
  }
}
public enum RxCocoaURLError : Swift.Error {
  case unknown
  case nonHTTPResponse(response: Foundation.URLResponse)
  case httpRequestFailed(response: Foundation.HTTPURLResponse, data: Foundation.Data?)
  case deserializationError(error: Swift.Error)
}
extension RxCocoaURLError : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension Reactive where Base : Foundation.URLSession {
  public func response(request: Foundation.URLRequest) -> RxSwift.Observable<(response: Foundation.HTTPURLResponse, data: Foundation.Data)>
  public func data(request: Foundation.URLRequest) -> RxSwift.Observable<Foundation.Data>
  public func json(request: Foundation.URLRequest, options: Foundation.JSONSerialization.ReadingOptions = []) -> RxSwift.Observable<Any>
  public func json(url: Foundation.URL) -> RxSwift.Observable<Any>
}
public protocol KVORepresentable {
  associatedtype KVOType
  init?(KVOValue: Self.KVOType)
}
extension ControlEvent {
  public func asDriver() -> RxCocoa.Driver<RxCocoa.ControlEvent<PropertyType>.Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  public func drive<Observer>(_ observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func drive<Observer>(_ observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func drive(_ relay: RxRelay.BehaviorRelay<Self.Element>) -> RxSwift.Disposable
  public func drive(_ relay: RxRelay.BehaviorRelay<Self.Element?>) -> RxSwift.Disposable
  public func drive<Result>(_ transformation: (RxSwift.Observable<Self.Element>) -> Result) -> Result
  public func drive<R1, R2>(_ with: (RxSwift.Observable<Self.Element>) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func drive(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.SignalSharingStrategy {
  public func emit<Observer>(to observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func emit<Observer>(to observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func emit(to relay: RxRelay.BehaviorRelay<Self.Element>) -> RxSwift.Disposable
  public func emit(to relay: RxRelay.BehaviorRelay<Self.Element?>) -> RxSwift.Disposable
  public func emit(to relay: RxRelay.PublishRelay<Self.Element>) -> RxSwift.Disposable
  public func emit(to relay: RxRelay.PublishRelay<Self.Element?>) -> RxSwift.Disposable
  public func emit(onNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, onDisposed: (() -> Swift.Void)? = nil) -> RxSwift.Disposable
}
extension Reactive where Base : AnyObject {
  public subscript<Value>(keyPath: Swift.ReferenceWritableKeyPath<Base, Value>) -> RxCocoa.Binder<Value> {
    get
  }
  public subscript<Value>(keyPath: Swift.ReferenceWritableKeyPath<Base, Value>, on scheduler: RxSwift.ImmediateSchedulerType) -> RxCocoa.Binder<Value> {
    get
  }
}
public enum RxCocoaError : Swift.Error, Swift.CustomDebugStringConvertible {
  case unknown
  case invalidOperation(object: Any)
  case itemsNotYetBound(object: Any)
  case invalidPropertyName(object: Any, propertyName: Swift.String)
  case invalidObjectOnKeyPath(object: Any, sourceObject: Swift.AnyObject, propertyName: Swift.String)
  case errorDuringSwizzling
  case castingError(object: Any, targetType: Any.Type)
}
extension RxCocoaError {
  public var debugDescription: Swift.String {
    get
  }
}
public struct SharedSequence<SharingStrategy, Element> : RxCocoa.SharedSequenceConvertibleType where SharingStrategy : RxCocoa.SharingStrategyProtocol {
  public func asObservable() -> RxSwift.Observable<Element>
  public func asSharedSequence() -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
public protocol SharingStrategyProtocol {
  static var scheduler: RxSwift.SchedulerType { get }
  static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
public protocol SharedSequenceConvertibleType : RxSwift.ObservableConvertibleType {
  associatedtype SharingStrategy : RxCocoa.SharingStrategyProtocol
  func asSharedSequence() -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func asObservable() -> RxSwift.Observable<Self.Element>
}
extension SharedSequence {
  public static func empty() -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func never() -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func just(_ element: Element) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func deferred(_ observableFactory: @escaping () -> RxCocoa.SharedSequence<SharingStrategy, Element>) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func of(_ elements: Element...) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func from(_ array: [Element]) -> RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func from<Sequence>(_ sequence: Sequence) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Element == Sequence.Element, Sequence : Swift.Sequence
  public static func from(optional: Element?) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  public static func interval(_ period: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  public static func timer(_ dueTime: RxSwift.RxTimeInterval, period: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2>(_ source1: O1, _ source2: O2) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2, resultSelector: @escaping (O1.Element, O2.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2>(_ source1: O1, _ source2: O2) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3, resultSelector: @escaping (O1.Element, O2.Element, O3.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3>(_ source1: O1, _ source2: O2, _ source3: O3) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy
}
extension SharedSequence {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> RxCocoa.SharedSequence<O1.SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func zip<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxCocoa.SharedSequence<O1.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequence {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8, resultSelector: @escaping (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element) throws -> Element) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy == O1.SharingStrategy, O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension SharedSequenceConvertibleType where Self.Element == Any {
  public static func combineLatest<O1, O2, O3, O4, O5, O6, O7, O8>(_ source1: O1, _ source2: O2, _ source3: O3, _ source4: O4, _ source5: O5, _ source6: O6, _ source7: O7, _ source8: O8) -> RxCocoa.SharedSequence<Self.SharingStrategy, (O1.Element, O2.Element, O3.Element, O4.Element, O5.Element, O6.Element, O7.Element, O8.Element)> where O1 : RxCocoa.SharedSequenceConvertibleType, O2 : RxCocoa.SharedSequenceConvertibleType, O3 : RxCocoa.SharedSequenceConvertibleType, O4 : RxCocoa.SharedSequenceConvertibleType, O5 : RxCocoa.SharedSequenceConvertibleType, O6 : RxCocoa.SharedSequenceConvertibleType, O7 : RxCocoa.SharedSequenceConvertibleType, O8 : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == O1.SharingStrategy, O1.SharingStrategy == O2.SharingStrategy, O2.SharingStrategy == O3.SharingStrategy, O3.SharingStrategy == O4.SharingStrategy, O4.SharingStrategy == O5.SharingStrategy, O5.SharingStrategy == O6.SharingStrategy, O6.SharingStrategy == O7.SharingStrategy, O7.SharingStrategy == O8.SharingStrategy
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : RxCocoa.KVORepresentable
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?> where Element : Swift.RawRepresentable, Element.RawValue : RxCocoa.KVORepresentable
}
extension CGRect : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGRect.KVOType)
}
extension CGPoint : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGPoint.KVOType)
}
extension CGSize : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSValue
  public init?(KVOValue: CoreGraphics.CGSize.KVOType)
}
extension ObservableType {
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  public func bind<Observer>(to observers: Observer...) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  public func bind<Result>(to binder: (Self) -> Result) -> Result
  public func bind<R1, R2>(to binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  public func bind(onNext: @escaping (Self.Element) -> Swift.Void) -> RxSwift.Disposable
}
extension ObservableType {
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Observer>(_ observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Self.Element == Observer.Element
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Observer>(_ observer: Observer) -> RxSwift.Disposable where Observer : RxSwift.ObserverType, Observer.Element == Self.Element?
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo(_ variable: RxSwift.Variable<Self.Element>) -> RxSwift.Disposable
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo(_ variable: RxSwift.Variable<Self.Element?>) -> RxSwift.Disposable
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<Result>(_ binder: (Self) -> Result) -> Result
  @available(*, deprecated, renamed: "bind(to:)")
  public func bindTo<R1, R2>(_ binder: (Self) -> (R1) -> R2, curriedArgument: R1) -> R2
  @available(*, deprecated, renamed: "bind(onNext:)")
  public func bindNext(_ onNext: @escaping (Self.Element) -> Swift.Void) -> RxSwift.Disposable
}
@available(*, deprecated, renamed: "SharingScheduler.mock(scheduler:action:)")
public func driveOnScheduler(_ scheduler: RxSwift.SchedulerType, action: () -> Swift.Void)
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension Variable {
  @available(*, deprecated, renamed: "asDriver()")
  final public func asSharedSequence<SharingStrategy>(strategy: SharingStrategy.Type = SharingStrategy.self) -> RxCocoa.SharedSequence<SharingStrategy, Element> where SharingStrategy : RxCocoa.SharingStrategyProtocol
}
extension DelegateProxy {
  @available(*, unavailable, renamed: "assignedProxy(for:)")
  public static func assignedProxyFor(_ object: RxCocoa.DelegateProxy<P, D>.ParentObject) -> RxCocoa.DelegateProxy<P, D>.Delegate?
  @available(*, unavailable, renamed: "currentDelegate(for:)")
  public static func currentDelegateFor(_ object: RxCocoa.DelegateProxy<P, D>.ParentObject) -> RxCocoa.DelegateProxy<P, D>.Delegate?
}
@available(*, deprecated, renamed: "Binder")
final public class UIBindingObserver<UIElement, Value> : RxSwift.ObserverType where UIElement : AnyObject {
  public typealias Element = Value
  @available(*, deprecated, renamed: "UIBinder.init(_:scheduler:binding:)")
  public init(UIElement: UIElement, binding: @escaping (UIElement, Value) -> Swift.Void)
  final public func on(_ event: RxSwift.Event<Value>)
  final public func asObserver() -> RxSwift.AnyObserver<Value>
  @objc deinit
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension Variable {
  final public func asDriver() -> RxCocoa.Driver<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.DriverSharingStrategy {
  @available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
  public func drive(_ variable: RxSwift.Variable<Self.Element>) -> RxSwift.Disposable
  @available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
  public func drive(_ variable: RxSwift.Variable<Self.Element?>) -> RxSwift.Disposable
}
@available(*, deprecated, message: "Variable is deprecated. Please use `BehaviorRelay` as a replacement.")
extension ObservableType {
  public func bind(to variable: RxSwift.Variable<Self.Element>) -> RxSwift.Disposable
  public func bind(to variable: RxSwift.Variable<Self.Element?>) -> RxSwift.Disposable
}
extension SharedSequenceConvertibleType {
  @available(*, deprecated, renamed: "timeout(_:latest:)", message: "Use DispatchTimeInterval overload instead.")
  public func throttle(_ dueTime: Foundation.TimeInterval, latest: Swift.Bool = true) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  @available(*, deprecated, renamed: "debounce(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func debounce(_ dueTime: Foundation.TimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  @available(*, deprecated, renamed: "delay(_:)", message: "Use DispatchTimeInterval overload instead.")
  public func delay(_ dueTime: Foundation.TimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "interval(_:)", message: "Use DispatchTimeInterval overload instead.")
  public static func interval(_ period: Foundation.TimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence where Element : Swift.FixedWidthInteger {
  @available(*, deprecated, renamed: "timer(_:)", message: "Use DispatchTimeInterval overload instead.")
  public static func timer(_ dueTime: Foundation.TimeInterval, period: Foundation.TimeInterval) -> RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension PublishRelay {
  final public func asSignal() -> RxCocoa.Signal<Element>
}
public typealias Signal<Element> = RxCocoa.SharedSequence<RxCocoa.SignalSharingStrategy, Element>
public struct SignalSharingStrategy : RxCocoa.SharingStrategyProtocol {
  public static var scheduler: RxSwift.SchedulerType {
    get
  }
  public static func share<Element>(_ source: RxSwift.Observable<Element>) -> RxSwift.Observable<Element>
}
extension SharedSequenceConvertibleType where Self.SharingStrategy == RxCocoa.SignalSharingStrategy {
  public func asSignal() -> RxCocoa.Signal<Self.Element>
}
extension ObservableConvertibleType {
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorJustReturn: Self.Element) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorDriveWith: RxCocoa.SharedSequence<S, Self.Element>) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
  public func asSharedSequence<S>(sharingStrategy: S.Type = S.self, onErrorRecover: @escaping (Swift.Error) -> RxCocoa.SharedSequence<S, Self.Element>) -> RxCocoa.SharedSequence<S, Self.Element> where S : RxCocoa.SharingStrategyProtocol
}
public protocol ControlPropertyType : RxSwift.ObservableType, RxSwift.ObserverType {
  func asControlProperty() -> RxCocoa.ControlProperty<Self.Element>
}
public struct ControlProperty<PropertyType> : RxCocoa.ControlPropertyType {
  public typealias Element = PropertyType
  public init<Values, Sink>(values: Values, valueSink: Sink) where PropertyType == Values.Element, Values : RxSwift.ObservableType, Sink : RxSwift.ObserverType, Values.Element == Sink.Element
  public func subscribe<Observer>(_ observer: Observer) -> RxSwift.Disposable where PropertyType == Observer.Element, Observer : RxSwift.ObserverType
  public var changed: RxCocoa.ControlEvent<PropertyType> {
    get
  }
  public func asObservable() -> RxSwift.Observable<RxCocoa.ControlProperty<PropertyType>.Element>
  public func asControlProperty() -> RxCocoa.ControlProperty<RxCocoa.ControlProperty<PropertyType>.Element>
  public func on(_ event: RxSwift.Event<RxCocoa.ControlProperty<PropertyType>.Element>)
}
extension ControlPropertyType where Self.Element == Swift.String? {
  public var orEmpty: RxCocoa.ControlProperty<Swift.String> {
    get
  }
}
extension SharedSequenceConvertibleType {
  public func map<Result>(_ selector: @escaping (Self.Element) -> Result) -> RxCocoa.SharedSequence<Self.SharingStrategy, Result>
}
extension SharedSequenceConvertibleType {
  public func filter(_ predicate: @escaping (Self.Element) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : RxCocoa.SharedSequenceConvertibleType {
  public func switchLatest() -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension SharedSequenceConvertibleType {
  public func flatMapLatest<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public func flatMapFirst<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public func `do`(onNext: ((Self.Element) -> Swift.Void)? = nil, afterNext: ((Self.Element) -> Swift.Void)? = nil, onCompleted: (() -> Swift.Void)? = nil, afterCompleted: (() -> Swift.Void)? = nil, onSubscribe: (() -> Swift.Void)? = nil, onSubscribed: (() -> Swift.Void)? = nil, onDispose: (() -> Swift.Void)? = nil) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func debug(_ identifier: Swift.String? = nil, trimOutput: Swift.Bool = false, file: Swift.String = #file, line: Swift.UInt = #line, function: Swift.String = #function) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : Swift.Equatable {
  public func distinctUntilChanged() -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func distinctUntilChanged<Key>(_ keySelector: @escaping (Self.Element) -> Key) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element> where Key : Swift.Equatable
  public func distinctUntilChanged(_ comparer: @escaping (Self.Element, Self.Element) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public func distinctUntilChanged<K>(_ keySelector: @escaping (Self.Element) -> K, comparer: @escaping (K, K) -> Swift.Bool) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func flatMap<Sharing, Result>(_ selector: @escaping (Self.Element) -> RxCocoa.SharedSequence<Sharing, Result>) -> RxCocoa.SharedSequence<Sharing, Result> where Sharing : RxCocoa.SharingStrategyProtocol
}
extension SharedSequenceConvertibleType {
  public static func merge<Collection>(_ sources: Collection) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: [RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>]) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public static func merge(_ sources: RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>...) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType where Self.Element : RxCocoa.SharedSequenceConvertibleType {
  public func merge() -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
  public func merge(maxConcurrent: Swift.Int) -> RxCocoa.SharedSequence<Self.Element.SharingStrategy, Self.Element.Element>
}
extension SharedSequenceConvertibleType {
  public func throttle(_ dueTime: RxSwift.RxTimeInterval, latest: Swift.Bool = true) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
  public func debounce(_ dueTime: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func scan<A>(_ seed: A, accumulator: @escaping (A, Self.Element) -> A) -> RxCocoa.SharedSequence<Self.SharingStrategy, A>
}
extension SharedSequence {
  public static func concat<Sequence>(_ sequence: Sequence) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Sequence : Swift.Sequence, Sequence.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func concat<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, Element> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func zip<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> RxCocoa.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func zip<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequence {
  public static func combineLatest<Collection, Result>(_ collection: Collection, resultSelector: @escaping ([Element]) throws -> Result) -> RxCocoa.SharedSequence<SharingStrategy, Result> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
  public static func combineLatest<Collection>(_ collection: Collection) -> RxCocoa.SharedSequence<SharingStrategy, [Element]> where Collection : Swift.Collection, Collection.Element == RxCocoa.SharedSequence<SharingStrategy, Element>
}
extension SharedSequenceConvertibleType {
  public func withLatestFrom<SecondO, ResultType>(_ second: SecondO, resultSelector: @escaping (Self.Element, SecondO.Element) -> ResultType) -> RxCocoa.SharedSequence<Self.SharingStrategy, ResultType> where SecondO : RxCocoa.SharedSequenceConvertibleType, Self.SharingStrategy == SecondO.SharingStrategy
  public func withLatestFrom<SecondO>(_ second: SecondO) -> RxCocoa.SharedSequence<Self.SharingStrategy, SecondO.Element> where SecondO : RxCocoa.SharedSequenceConvertibleType
}
extension SharedSequenceConvertibleType {
  public func skip(_ count: Swift.Int) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func startWith(_ element: Self.Element) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension SharedSequenceConvertibleType {
  public func delay(_ dueTime: RxSwift.RxTimeInterval) -> RxCocoa.SharedSequence<Self.SharingStrategy, Self.Element>
}
extension Int : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int.KVOType)
}
extension Int32 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int32.KVOType)
}
extension Int64 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Int64.KVOType)
}
extension UInt : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt.KVOType)
}
extension UInt32 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt32.KVOType)
}
extension UInt64 : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.UInt64.KVOType)
}
extension Bool : RxCocoa.KVORepresentable {
  public typealias KVOType = Foundation.NSNumber
  public init?(KVOValue: Swift.Bool.KVOType)
}
extension ObservableConvertibleType {
  public func asDriver(onErrorJustReturn: Self.Element) -> RxCocoa.Driver<Self.Element>
  public func asDriver(onErrorDriveWith: RxCocoa.Driver<Self.Element>) -> RxCocoa.Driver<Self.Element>
  public func asDriver(onErrorRecover: @escaping (Swift.Error) -> RxCocoa.Driver<Self.Element>) -> RxCocoa.Driver<Self.Element>
}
public struct KeyValueObservingOptions : Swift.OptionSet {
  public let rawValue: Swift.UInt
  public init(rawValue: Swift.UInt)
  public static let initial: RxCocoa.KeyValueObservingOptions
  public static let new: RxCocoa.KeyValueObservingOptions
  public typealias Element = RxCocoa.KeyValueObservingOptions
  public typealias ArrayLiteralElement = RxCocoa.KeyValueObservingOptions
  public typealias RawValue = Swift.UInt
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?> where Element : RxCocoa.KVORepresentable
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?> where Element : RxCocoa.KVORepresentable
}
extension ControlProperty {
  public func asDriver() -> RxCocoa.Driver<RxCocoa.ControlProperty<PropertyType>.Element>
}
open class DelegateProxy<P, D> : RxCocoa._RXDelegateProxy where P : AnyObject {
  public typealias ParentObject = P
  public typealias Delegate = D
  public init<Proxy>(parentObject: RxCocoa.DelegateProxy<P, D>.ParentObject, delegateProxy: Proxy.Type) where P == Proxy.ParentObject, D == Proxy.Delegate, Proxy : RxCocoa.DelegateProxy<P, D>, Proxy : RxCocoa.DelegateProxyType
  open func sentMessage(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  open func methodInvoked(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  @objc override dynamic open func _sentMessage(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  @objc override dynamic open func _methodInvoked(_ selector: ObjectiveC.Selector, withArguments arguments: [Any])
  open func forwardToDelegate() -> RxCocoa.DelegateProxy<P, D>.Delegate?
  open func setForwardToDelegate(_ delegate: RxCocoa.DelegateProxy<P, D>.Delegate?, retainDelegate: Swift.Bool)
  @objc override dynamic open func responds(to aSelector: ObjectiveC.Selector!) -> Swift.Bool
  @objc deinit
  @objc override dynamic public init()
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observe<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial], retainSelf: Swift.Bool = true) -> RxSwift.Observable<Element?>
}
extension Reactive where Base : ObjectiveC.NSObject {
  public func observeWeakly<Element>(_ type: Element.Type, _ keyPath: Swift.String, options: RxCocoa.KeyValueObservingOptions = [.new, .initial]) -> RxSwift.Observable<Element?>
}
extension Reactive where Base : AnyObject {
  public var deallocated: RxSwift.Observable<Swift.Void> {
    get
  }
  public func sentMessage(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  public func methodInvoked(_ selector: ObjectiveC.Selector) -> RxSwift.Observable<[Any]>
  public var deallocating: RxSwift.Observable<()> {
    get
  }
}
extension Reactive where Base : Foundation.NotificationCenter {
  public func notification(_ name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> RxSwift.Observable<Foundation.Notification>
}
extension RxCocoa.RxCocoaInterceptionMechanism : Swift.Equatable {}
extension RxCocoa.RxCocoaInterceptionMechanism : Swift.Hashable {}

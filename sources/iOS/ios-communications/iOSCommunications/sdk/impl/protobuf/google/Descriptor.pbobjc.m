// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: descriptor.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Descriptor.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - GPBDescriptorRoot

@implementation GPBDescriptorRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - GPBDescriptorRoot_FileDescriptor

static GPBFileDescriptor *GPBDescriptorRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"google.protobuf"
                                                 objcPrefix:@"GPB"
                                                     syntax:GPBFileSyntaxProto2];
  }
  return descriptor;
}

#pragma mark - GPBFileDescriptorSet

@implementation GPBFileDescriptorSet

@dynamic fileArray, fileArray_Count;

typedef struct GPBFileDescriptorSet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *fileArray;
} GPBFileDescriptorSet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFileDescriptorProto),
        .number = GPBFileDescriptorSet_FieldNumber_FileArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorSet__storage_, fileArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBFileDescriptorSet class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBFileDescriptorSet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBFileDescriptorProto

@implementation GPBFileDescriptorProto

@dynamic hasName, name;
@dynamic hasPackage, package;
@dynamic dependencyArray, dependencyArray_Count;
@dynamic publicDependencyArray, publicDependencyArray_Count;
@dynamic weakDependencyArray, weakDependencyArray_Count;
@dynamic messageTypeArray, messageTypeArray_Count;
@dynamic enumTypeArray, enumTypeArray_Count;
@dynamic serviceArray, serviceArray_Count;
@dynamic extensionArray, extensionArray_Count;
@dynamic hasOptions, options;
@dynamic hasSourceCodeInfo, sourceCodeInfo;
@dynamic hasSyntax, syntax;

typedef struct GPBFileDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *package;
  NSMutableArray *dependencyArray;
  NSMutableArray *messageTypeArray;
  NSMutableArray *enumTypeArray;
  NSMutableArray *serviceArray;
  NSMutableArray *extensionArray;
  GPBFileOptions *options;
  GPBSourceCodeInfo *sourceCodeInfo;
  GPBInt32Array *publicDependencyArray;
  GPBInt32Array *weakDependencyArray;
  NSString *syntax;
} GPBFileDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "package",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_Package,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, package),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "dependencyArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_DependencyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, dependencyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "messageTypeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDescriptorProto),
        .number = GPBFileDescriptorProto_FieldNumber_MessageTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, messageTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enumTypeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBEnumDescriptorProto),
        .number = GPBFileDescriptorProto_FieldNumber_EnumTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, enumTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "serviceArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBServiceDescriptorProto),
        .number = GPBFileDescriptorProto_FieldNumber_ServiceArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, serviceArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldDescriptorProto),
        .number = GPBFileDescriptorProto_FieldNumber_ExtensionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, extensionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFileOptions),
        .number = GPBFileDescriptorProto_FieldNumber_Options,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourceCodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBSourceCodeInfo),
        .number = GPBFileDescriptorProto_FieldNumber_SourceCodeInfo,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, sourceCodeInfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "publicDependencyArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_PublicDependencyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, publicDependencyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "weakDependencyArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_WeakDependencyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, weakDependencyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "syntax",
        .dataTypeSpecific.className = NULL,
        .number = GPBFileDescriptorProto_FieldNumber_Syntax,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GPBFileDescriptorProto__storage_, syntax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBFileDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBFileDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBDescriptorProto

@implementation GPBDescriptorProto

@dynamic hasName, name;
@dynamic fieldArray, fieldArray_Count;
@dynamic extensionArray, extensionArray_Count;
@dynamic nestedTypeArray, nestedTypeArray_Count;
@dynamic enumTypeArray, enumTypeArray_Count;
@dynamic extensionRangeArray, extensionRangeArray_Count;
@dynamic oneofDeclArray, oneofDeclArray_Count;
@dynamic hasOptions, options;
@dynamic reservedRangeArray, reservedRangeArray_Count;
@dynamic reservedNameArray, reservedNameArray_Count;

typedef struct GPBDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *fieldArray;
  NSMutableArray *nestedTypeArray;
  NSMutableArray *enumTypeArray;
  NSMutableArray *extensionRangeArray;
  NSMutableArray *extensionArray;
  GPBMessageOptions *options;
  NSMutableArray *oneofDeclArray;
  NSMutableArray *reservedRangeArray;
  NSMutableArray *reservedNameArray;
} GPBDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "fieldArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldDescriptorProto),
        .number = GPBDescriptorProto_FieldNumber_FieldArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, fieldArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "nestedTypeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDescriptorProto),
        .number = GPBDescriptorProto_FieldNumber_NestedTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, nestedTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "enumTypeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBEnumDescriptorProto),
        .number = GPBDescriptorProto_FieldNumber_EnumTypeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, enumTypeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionRangeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDescriptorProto_ExtensionRange),
        .number = GPBDescriptorProto_FieldNumber_ExtensionRangeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, extensionRangeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "extensionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBFieldDescriptorProto),
        .number = GPBDescriptorProto_FieldNumber_ExtensionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, extensionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBMessageOptions),
        .number = GPBDescriptorProto_FieldNumber_Options,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "oneofDeclArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBOneofDescriptorProto),
        .number = GPBDescriptorProto_FieldNumber_OneofDeclArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, oneofDeclArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reservedRangeArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBDescriptorProto_ReservedRange),
        .number = GPBDescriptorProto_FieldNumber_ReservedRangeArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, reservedRangeArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "reservedNameArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_FieldNumber_ReservedNameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBDescriptorProto__storage_, reservedNameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBDescriptorProto_ExtensionRange

@implementation GPBDescriptorProto_ExtensionRange

@dynamic hasStart, start;
@dynamic hasEnd, end;
@dynamic hasOptions, options;

typedef struct GPBDescriptorProto_ExtensionRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t start;
  int32_t end;
  GPBExtensionRangeOptions *options;
} GPBDescriptorProto_ExtensionRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_ExtensionRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBDescriptorProto_ExtensionRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_ExtensionRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBDescriptorProto_ExtensionRange__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBExtensionRangeOptions),
        .number = GPBDescriptorProto_ExtensionRange_FieldNumber_Options,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBDescriptorProto_ExtensionRange__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBDescriptorProto_ExtensionRange class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBDescriptorProto_ExtensionRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GPBDescriptorProto)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBDescriptorProto_ReservedRange

@implementation GPBDescriptorProto_ReservedRange

@dynamic hasStart, start;
@dynamic hasEnd, end;

typedef struct GPBDescriptorProto_ReservedRange__storage_ {
  uint32_t _has_storage_[1];
  int32_t start;
  int32_t end;
} GPBDescriptorProto_ReservedRange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "start",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_ReservedRange_FieldNumber_Start,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBDescriptorProto_ReservedRange__storage_, start),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GPBDescriptorProto_ReservedRange_FieldNumber_End,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBDescriptorProto_ReservedRange__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBDescriptorProto_ReservedRange class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBDescriptorProto_ReservedRange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GPBDescriptorProto)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBExtensionRangeOptions

@implementation GPBExtensionRangeOptions

@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBExtensionRangeOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBExtensionRangeOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBExtensionRangeOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBExtensionRangeOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBExtensionRangeOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBExtensionRangeOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBFieldDescriptorProto

@implementation GPBFieldDescriptorProto

@dynamic hasName, name;
@dynamic hasNumber, number;
@dynamic hasLabel, label;
@dynamic hasType, type;
@dynamic hasTypeName, typeName;
@dynamic hasExtendee, extendee;
@dynamic hasDefaultValue, defaultValue;
@dynamic hasOneofIndex, oneofIndex;
@dynamic hasJsonName, jsonName;
@dynamic hasOptions, options;

typedef struct GPBFieldDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  int32_t number;
  GPBFieldDescriptorProto_Label label;
  GPBFieldDescriptorProto_Type type;
  int32_t oneofIndex;
  NSString *name;
  NSString *extendee;
  NSString *typeName;
  NSString *defaultValue;
  GPBFieldOptions *options;
  NSString *jsonName;
} GPBFieldDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "name",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_Name,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, name),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "extendee",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_Extendee,
        .core.hasIndex = 5,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, extendee),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "number",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_Number,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, number),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueEnum = GPBFieldDescriptorProto_Label_LabelOptional,
        .core.name = "label",
        .core.dataTypeSpecific.enumDescFunc = GPBFieldDescriptorProto_Label_EnumDescriptor,
        .core.number = GPBFieldDescriptorProto_FieldNumber_Label,
        .core.hasIndex = 2,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, label),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueEnum = GPBFieldDescriptorProto_Type_TypeDouble,
        .core.name = "type",
        .core.dataTypeSpecific.enumDescFunc = GPBFieldDescriptorProto_Type_EnumDescriptor,
        .core.number = GPBFieldDescriptorProto_FieldNumber_Type,
        .core.hasIndex = 3,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, type),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "typeName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_TypeName,
        .core.hasIndex = 4,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, typeName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "defaultValue",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_DefaultValue,
        .core.hasIndex = 6,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, defaultValue),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "options",
        .core.dataTypeSpecific.className = GPBStringifySymbol(GPBFieldOptions),
        .core.number = GPBFieldDescriptorProto_FieldNumber_Options,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, options),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeMessage,
      },
      {
        .defaultValue.valueInt32 = 0,
        .core.name = "oneofIndex",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_OneofIndex,
        .core.hasIndex = 7,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, oneofIndex),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeInt32,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "jsonName",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFieldDescriptorProto_FieldNumber_JsonName,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(GPBFieldDescriptorProto__storage_, jsonName),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBFieldDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(GPBFieldDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GPBFieldDescriptorProto_Type

GPBEnumDescriptor *GPBFieldDescriptorProto_Type_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "TypeDouble\000TypeFloat\000TypeInt64\000TypeUint6"
        "4\000TypeInt32\000TypeFixed64\000TypeFixed32\000Type"
        "Bool\000TypeString\000TypeGroup\000TypeMessage\000Ty"
        "peBytes\000TypeUint32\000TypeEnum\000TypeSfixed32"
        "\000TypeSfixed64\000TypeSint32\000TypeSint64\000";
    static const int32_t values[] = {
        GPBFieldDescriptorProto_Type_TypeDouble,
        GPBFieldDescriptorProto_Type_TypeFloat,
        GPBFieldDescriptorProto_Type_TypeInt64,
        GPBFieldDescriptorProto_Type_TypeUint64,
        GPBFieldDescriptorProto_Type_TypeInt32,
        GPBFieldDescriptorProto_Type_TypeFixed64,
        GPBFieldDescriptorProto_Type_TypeFixed32,
        GPBFieldDescriptorProto_Type_TypeBool,
        GPBFieldDescriptorProto_Type_TypeString,
        GPBFieldDescriptorProto_Type_TypeGroup,
        GPBFieldDescriptorProto_Type_TypeMessage,
        GPBFieldDescriptorProto_Type_TypeBytes,
        GPBFieldDescriptorProto_Type_TypeUint32,
        GPBFieldDescriptorProto_Type_TypeEnum,
        GPBFieldDescriptorProto_Type_TypeSfixed32,
        GPBFieldDescriptorProto_Type_TypeSfixed64,
        GPBFieldDescriptorProto_Type_TypeSint32,
        GPBFieldDescriptorProto_Type_TypeSint64,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBFieldDescriptorProto_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBFieldDescriptorProto_Type_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBFieldDescriptorProto_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBFieldDescriptorProto_Type_TypeDouble:
    case GPBFieldDescriptorProto_Type_TypeFloat:
    case GPBFieldDescriptorProto_Type_TypeInt64:
    case GPBFieldDescriptorProto_Type_TypeUint64:
    case GPBFieldDescriptorProto_Type_TypeInt32:
    case GPBFieldDescriptorProto_Type_TypeFixed64:
    case GPBFieldDescriptorProto_Type_TypeFixed32:
    case GPBFieldDescriptorProto_Type_TypeBool:
    case GPBFieldDescriptorProto_Type_TypeString:
    case GPBFieldDescriptorProto_Type_TypeGroup:
    case GPBFieldDescriptorProto_Type_TypeMessage:
    case GPBFieldDescriptorProto_Type_TypeBytes:
    case GPBFieldDescriptorProto_Type_TypeUint32:
    case GPBFieldDescriptorProto_Type_TypeEnum:
    case GPBFieldDescriptorProto_Type_TypeSfixed32:
    case GPBFieldDescriptorProto_Type_TypeSfixed64:
    case GPBFieldDescriptorProto_Type_TypeSint32:
    case GPBFieldDescriptorProto_Type_TypeSint64:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GPBFieldDescriptorProto_Label

GPBEnumDescriptor *GPBFieldDescriptorProto_Label_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "LabelOptional\000LabelRequired\000LabelRepeate"
        "d\000";
    static const int32_t values[] = {
        GPBFieldDescriptorProto_Label_LabelOptional,
        GPBFieldDescriptorProto_Label_LabelRequired,
        GPBFieldDescriptorProto_Label_LabelRepeated,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBFieldDescriptorProto_Label)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBFieldDescriptorProto_Label_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBFieldDescriptorProto_Label_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBFieldDescriptorProto_Label_LabelOptional:
    case GPBFieldDescriptorProto_Label_LabelRequired:
    case GPBFieldDescriptorProto_Label_LabelRepeated:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GPBOneofDescriptorProto

@implementation GPBOneofDescriptorProto

@dynamic hasName, name;
@dynamic hasOptions, options;

typedef struct GPBOneofDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  GPBOneofOptions *options;
} GPBOneofDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBOneofDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBOneofDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBOneofOptions),
        .number = GPBOneofDescriptorProto_FieldNumber_Options,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBOneofDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBOneofDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBOneofDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBEnumDescriptorProto

@implementation GPBEnumDescriptorProto

@dynamic hasName, name;
@dynamic valueArray, valueArray_Count;
@dynamic hasOptions, options;

typedef struct GPBEnumDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *valueArray;
  GPBEnumOptions *options;
} GPBEnumDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBEnumDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "valueArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBEnumValueDescriptorProto),
        .number = GPBEnumDescriptorProto_FieldNumber_ValueArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBEnumDescriptorProto__storage_, valueArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBEnumOptions),
        .number = GPBEnumDescriptorProto_FieldNumber_Options,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBEnumDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBEnumDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBEnumDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBEnumValueDescriptorProto

@implementation GPBEnumValueDescriptorProto

@dynamic hasName, name;
@dynamic hasNumber, number;
@dynamic hasOptions, options;

typedef struct GPBEnumValueDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  int32_t number;
  NSString *name;
  GPBEnumValueOptions *options;
} GPBEnumValueDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumValueDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBEnumValueDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumValueDescriptorProto_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBEnumValueDescriptorProto__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBEnumValueOptions),
        .number = GPBEnumValueDescriptorProto_FieldNumber_Options,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBEnumValueDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBEnumValueDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBEnumValueDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBServiceDescriptorProto

@implementation GPBServiceDescriptorProto

@dynamic hasName, name;
@dynamic methodArray, methodArray_Count;
@dynamic hasOptions, options;

typedef struct GPBServiceDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSMutableArray *methodArray;
  GPBServiceOptions *options;
} GPBServiceDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBServiceDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBServiceDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "methodArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBMethodDescriptorProto),
        .number = GPBServiceDescriptorProto_FieldNumber_MethodArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBServiceDescriptorProto__storage_, methodArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBServiceOptions),
        .number = GPBServiceDescriptorProto_FieldNumber_Options,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBServiceDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBServiceDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBServiceDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBMethodDescriptorProto

@implementation GPBMethodDescriptorProto

@dynamic hasName, name;
@dynamic hasInputType, inputType;
@dynamic hasOutputType, outputType;
@dynamic hasOptions, options;
@dynamic hasClientStreaming, clientStreaming;
@dynamic hasServerStreaming, serverStreaming;

typedef struct GPBMethodDescriptorProto__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *inputType;
  NSString *outputType;
  GPBMethodOptions *options;
} GPBMethodDescriptorProto__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodDescriptorProto_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBMethodDescriptorProto__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "inputType",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodDescriptorProto_FieldNumber_InputType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBMethodDescriptorProto__storage_, inputType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "outputType",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodDescriptorProto_FieldNumber_OutputType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBMethodDescriptorProto__storage_, outputType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "options",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBMethodOptions),
        .number = GPBMethodDescriptorProto_FieldNumber_Options,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GPBMethodDescriptorProto__storage_, options),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "clientStreaming",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodDescriptorProto_FieldNumber_ClientStreaming,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "serverStreaming",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodDescriptorProto_FieldNumber_ServerStreaming,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBMethodDescriptorProto class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBMethodDescriptorProto__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBFileOptions

@implementation GPBFileOptions

@dynamic hasJavaPackage, javaPackage;
@dynamic hasJavaOuterClassname, javaOuterClassname;
@dynamic hasJavaMultipleFiles, javaMultipleFiles;
@dynamic hasJavaGenerateEqualsAndHash, javaGenerateEqualsAndHash;
@dynamic hasJavaStringCheckUtf8, javaStringCheckUtf8;
@dynamic hasOptimizeFor, optimizeFor;
@dynamic hasGoPackage, goPackage;
@dynamic hasCcGenericServices, ccGenericServices;
@dynamic hasJavaGenericServices, javaGenericServices;
@dynamic hasPyGenericServices, pyGenericServices;
@dynamic hasPhpGenericServices, phpGenericServices;
@dynamic hasDeprecated, deprecated;
@dynamic hasCcEnableArenas, ccEnableArenas;
@dynamic hasObjcClassPrefix, objcClassPrefix;
@dynamic hasCsharpNamespace, csharpNamespace;
@dynamic hasSwiftPrefix, swiftPrefix;
@dynamic hasPhpClassPrefix, phpClassPrefix;
@dynamic hasPhpNamespace, phpNamespace;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBFileOptions__storage_ {
  uint32_t _has_storage_[1];
  GPBFileOptions_OptimizeMode optimizeFor;
  NSString *javaPackage;
  NSString *javaOuterClassname;
  NSString *goPackage;
  NSString *objcClassPrefix;
  NSString *csharpNamespace;
  NSString *swiftPrefix;
  NSString *phpClassPrefix;
  NSString *phpNamespace;
  NSMutableArray *uninterpretedOptionArray;
} GPBFileOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescriptionWithDefault fields[] = {
      {
        .defaultValue.valueString = nil,
        .core.name = "javaPackage",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaPackage,
        .core.hasIndex = 0,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, javaPackage),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "javaOuterClassname",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaOuterClassname,
        .core.hasIndex = 1,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, javaOuterClassname),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueEnum = GPBFileOptions_OptimizeMode_Speed,
        .core.name = "optimizeFor",
        .core.dataTypeSpecific.enumDescFunc = GPBFileOptions_OptimizeMode_EnumDescriptor,
        .core.number = GPBFileOptions_FieldNumber_OptimizeFor,
        .core.hasIndex = 8,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, optimizeFor),
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .core.dataType = GPBDataTypeEnum,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "javaMultipleFiles",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaMultipleFiles,
        .core.hasIndex = 2,
        .core.offset = 3,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "goPackage",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_GoPackage,
        .core.hasIndex = 9,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, goPackage),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ccGenericServices",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_CcGenericServices,
        .core.hasIndex = 10,
        .core.offset = 11,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "javaGenericServices",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaGenericServices,
        .core.hasIndex = 12,
        .core.offset = 13,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "pyGenericServices",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_PyGenericServices,
        .core.hasIndex = 14,
        .core.offset = 15,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "phpGenericServices",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_PhpGenericServices,
        .core.hasIndex = 16,
        .core.offset = 17,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "javaGenerateEqualsAndHash",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaGenerateEqualsAndHash,
        .core.hasIndex = 4,
        .core.offset = 5,  // Stored in _has_storage_ to save space.
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "deprecated",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_Deprecated,
        .core.hasIndex = 18,
        .core.offset = 19,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "javaStringCheckUtf8",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_JavaStringCheckUtf8,
        .core.hasIndex = 6,
        .core.offset = 7,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueBool = NO,
        .core.name = "ccEnableArenas",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_CcEnableArenas,
        .core.hasIndex = 20,
        .core.offset = 21,  // Stored in _has_storage_ to save space.
        .core.flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .core.dataType = GPBDataTypeBool,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "objcClassPrefix",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_ObjcClassPrefix,
        .core.hasIndex = 22,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, objcClassPrefix),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "csharpNamespace",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_CsharpNamespace,
        .core.hasIndex = 23,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, csharpNamespace),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "swiftPrefix",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_SwiftPrefix,
        .core.hasIndex = 24,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, swiftPrefix),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "phpClassPrefix",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_PhpClassPrefix,
        .core.hasIndex = 25,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, phpClassPrefix),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueString = nil,
        .core.name = "phpNamespace",
        .core.dataTypeSpecific.className = NULL,
        .core.number = GPBFileOptions_FieldNumber_PhpNamespace,
        .core.hasIndex = 26,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, phpNamespace),
        .core.flags = GPBFieldOptional,
        .core.dataType = GPBDataTypeString,
      },
      {
        .defaultValue.valueMessage = nil,
        .core.name = "uninterpretedOptionArray",
        .core.dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .core.number = GPBFileOptions_FieldNumber_UninterpretedOptionArray,
        .core.hasIndex = GPBNoHasBit,
        .core.offset = (uint32_t)offsetof(GPBFileOptions__storage_, uninterpretedOptionArray),
        .core.flags = GPBFieldRepeated,
        .core.dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBFileOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescriptionWithDefault))
                                   storageSize:sizeof(GPBFileOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_FieldsWithDefault];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GPBFileOptions_OptimizeMode

GPBEnumDescriptor *GPBFileOptions_OptimizeMode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Speed\000CodeSize\000LiteRuntime\000";
    static const int32_t values[] = {
        GPBFileOptions_OptimizeMode_Speed,
        GPBFileOptions_OptimizeMode_CodeSize,
        GPBFileOptions_OptimizeMode_LiteRuntime,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBFileOptions_OptimizeMode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBFileOptions_OptimizeMode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBFileOptions_OptimizeMode_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBFileOptions_OptimizeMode_Speed:
    case GPBFileOptions_OptimizeMode_CodeSize:
    case GPBFileOptions_OptimizeMode_LiteRuntime:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GPBMessageOptions

@implementation GPBMessageOptions

@dynamic hasMessageSetWireFormat, messageSetWireFormat;
@dynamic hasNoStandardDescriptorAccessor, noStandardDescriptorAccessor;
@dynamic hasDeprecated, deprecated;
@dynamic hasMapEntry, mapEntry;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBMessageOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBMessageOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "messageSetWireFormat",
        .dataTypeSpecific.className = NULL,
        .number = GPBMessageOptions_FieldNumber_MessageSetWireFormat,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "noStandardDescriptorAccessor",
        .dataTypeSpecific.className = NULL,
        .number = GPBMessageOptions_FieldNumber_NoStandardDescriptorAccessor,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBMessageOptions_FieldNumber_Deprecated,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "mapEntry",
        .dataTypeSpecific.className = NULL,
        .number = GPBMessageOptions_FieldNumber_MapEntry,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBMessageOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBMessageOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBMessageOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBMessageOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBFieldOptions

@implementation GPBFieldOptions

@dynamic hasCtype, ctype;
@dynamic hasPacked, packed;
@dynamic hasJstype, jstype;
@dynamic hasLazy, lazy;
@dynamic hasDeprecated, deprecated;
@dynamic hasWeak, weak;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBFieldOptions__storage_ {
  uint32_t _has_storage_[1];
  GPBFieldOptions_CType ctype;
  GPBFieldOptions_JSType jstype;
  NSMutableArray *uninterpretedOptionArray;
} GPBFieldOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "ctype",
        .dataTypeSpecific.enumDescFunc = GPBFieldOptions_CType_EnumDescriptor,
        .number = GPBFieldOptions_FieldNumber_Ctype,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBFieldOptions__storage_, ctype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "packed",
        .dataTypeSpecific.className = NULL,
        .number = GPBFieldOptions_FieldNumber_Packed,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBFieldOptions_FieldNumber_Deprecated,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "lazy",
        .dataTypeSpecific.className = NULL,
        .number = GPBFieldOptions_FieldNumber_Lazy,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "jstype",
        .dataTypeSpecific.enumDescFunc = GPBFieldOptions_JSType_EnumDescriptor,
        .number = GPBFieldOptions_FieldNumber_Jstype,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GPBFieldOptions__storage_, jstype),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "weak",
        .dataTypeSpecific.className = NULL,
        .number = GPBFieldOptions_FieldNumber_Weak,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBFieldOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBFieldOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBFieldOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBFieldOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GPBFieldOptions_CType

GPBEnumDescriptor *GPBFieldOptions_CType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "String\000Cord\000StringPiece\000";
    static const int32_t values[] = {
        GPBFieldOptions_CType_String,
        GPBFieldOptions_CType_Cord,
        GPBFieldOptions_CType_StringPiece,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBFieldOptions_CType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBFieldOptions_CType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBFieldOptions_CType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBFieldOptions_CType_String:
    case GPBFieldOptions_CType_Cord:
    case GPBFieldOptions_CType_StringPiece:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum GPBFieldOptions_JSType

GPBEnumDescriptor *GPBFieldOptions_JSType_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "JsNormal\000JsString\000JsNumber\000";
    static const int32_t values[] = {
        GPBFieldOptions_JSType_JsNormal,
        GPBFieldOptions_JSType_JsString,
        GPBFieldOptions_JSType_JsNumber,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBFieldOptions_JSType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBFieldOptions_JSType_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBFieldOptions_JSType_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBFieldOptions_JSType_JsNormal:
    case GPBFieldOptions_JSType_JsString:
    case GPBFieldOptions_JSType_JsNumber:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GPBOneofOptions

@implementation GPBOneofOptions

@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBOneofOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBOneofOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBOneofOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBOneofOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBOneofOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBOneofOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBEnumOptions

@implementation GPBEnumOptions

@dynamic hasAllowAlias, allowAlias;
@dynamic hasDeprecated, deprecated;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBEnumOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBEnumOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "allowAlias",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumOptions_FieldNumber_AllowAlias,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumOptions_FieldNumber_Deprecated,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBEnumOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBEnumOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBEnumOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBEnumOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBEnumValueOptions

@implementation GPBEnumValueOptions

@dynamic hasDeprecated, deprecated;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBEnumValueOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBEnumValueOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBEnumValueOptions_FieldNumber_Deprecated,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBEnumValueOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBEnumValueOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBEnumValueOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBEnumValueOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBServiceOptions

@implementation GPBServiceOptions

@dynamic hasDeprecated, deprecated;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBServiceOptions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *uninterpretedOptionArray;
} GPBServiceOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBServiceOptions_FieldNumber_Deprecated,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBServiceOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBServiceOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBServiceOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBServiceOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBMethodOptions

@implementation GPBMethodOptions

@dynamic hasDeprecated, deprecated;
@dynamic hasIdempotencyLevel, idempotencyLevel;
@dynamic uninterpretedOptionArray, uninterpretedOptionArray_Count;

typedef struct GPBMethodOptions__storage_ {
  uint32_t _has_storage_[1];
  GPBMethodOptions_IdempotencyLevel idempotencyLevel;
  NSMutableArray *uninterpretedOptionArray;
} GPBMethodOptions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deprecated",
        .dataTypeSpecific.className = NULL,
        .number = GPBMethodOptions_FieldNumber_Deprecated,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "idempotencyLevel",
        .dataTypeSpecific.enumDescFunc = GPBMethodOptions_IdempotencyLevel_EnumDescriptor,
        .number = GPBMethodOptions_FieldNumber_IdempotencyLevel,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBMethodOptions__storage_, idempotencyLevel),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasDefaultValue | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "uninterpretedOptionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption),
        .number = GPBMethodOptions_FieldNumber_UninterpretedOptionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBMethodOptions__storage_, uninterpretedOptionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBMethodOptions class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBMethodOptions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const GPBExtensionRange ranges[] = {
      { .start = 1000, .end = 536870912 },
    };
    [localDescriptor setupExtensionRanges:ranges
                                    count:(uint32_t)(sizeof(ranges) / sizeof(GPBExtensionRange))];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Enum GPBMethodOptions_IdempotencyLevel

GPBEnumDescriptor *GPBMethodOptions_IdempotencyLevel_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "IdempotencyUnknown\000NoSideEffects\000Idempot"
        "ent\000";
    static const int32_t values[] = {
        GPBMethodOptions_IdempotencyLevel_IdempotencyUnknown,
        GPBMethodOptions_IdempotencyLevel_NoSideEffects,
        GPBMethodOptions_IdempotencyLevel_Idempotent,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(GPBMethodOptions_IdempotencyLevel)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:GPBMethodOptions_IdempotencyLevel_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL GPBMethodOptions_IdempotencyLevel_IsValidValue(int32_t value__) {
  switch (value__) {
    case GPBMethodOptions_IdempotencyLevel_IdempotencyUnknown:
    case GPBMethodOptions_IdempotencyLevel_NoSideEffects:
    case GPBMethodOptions_IdempotencyLevel_Idempotent:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - GPBUninterpretedOption

@implementation GPBUninterpretedOption

@dynamic nameArray, nameArray_Count;
@dynamic hasIdentifierValue, identifierValue;
@dynamic hasPositiveIntValue, positiveIntValue;
@dynamic hasNegativeIntValue, negativeIntValue;
@dynamic hasDoubleValue, doubleValue;
@dynamic hasStringValue, stringValue;
@dynamic hasAggregateValue, aggregateValue;

typedef struct GPBUninterpretedOption__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *nameArray;
  NSString *identifierValue;
  NSData *stringValue;
  NSString *aggregateValue;
  uint64_t positiveIntValue;
  int64_t negativeIntValue;
  double doubleValue;
} GPBUninterpretedOption__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "nameArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBUninterpretedOption_NamePart),
        .number = GPBUninterpretedOption_FieldNumber_NameArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, nameArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "identifierValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_IdentifierValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, identifierValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "positiveIntValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_PositiveIntValue,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, positiveIntValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "negativeIntValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_NegativeIntValue,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, negativeIntValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "doubleValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_DoubleValue,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, doubleValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "stringValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_StringValue,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, stringValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "aggregateValue",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_FieldNumber_AggregateValue,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption__storage_, aggregateValue),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBUninterpretedOption class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBUninterpretedOption__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBUninterpretedOption_NamePart

@implementation GPBUninterpretedOption_NamePart

@dynamic hasNamePart, namePart;
@dynamic hasIsExtension, isExtension;

typedef struct GPBUninterpretedOption_NamePart__storage_ {
  uint32_t _has_storage_[1];
  NSString *namePart;
} GPBUninterpretedOption_NamePart__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "namePart",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_NamePart_FieldNumber_NamePart,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBUninterpretedOption_NamePart__storage_, namePart),
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isExtension",
        .dataTypeSpecific.className = NULL,
        .number = GPBUninterpretedOption_NamePart_FieldNumber_IsExtension,
        .hasIndex = 1,
        .offset = 2,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldRequired,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBUninterpretedOption_NamePart class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBUninterpretedOption_NamePart__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GPBUninterpretedOption)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBSourceCodeInfo

@implementation GPBSourceCodeInfo

@dynamic locationArray, locationArray_Count;

typedef struct GPBSourceCodeInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *locationArray;
} GPBSourceCodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "locationArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBSourceCodeInfo_Location),
        .number = GPBSourceCodeInfo_FieldNumber_LocationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo__storage_, locationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBSourceCodeInfo class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBSourceCodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBSourceCodeInfo_Location

@implementation GPBSourceCodeInfo_Location

@dynamic pathArray, pathArray_Count;
@dynamic spanArray, spanArray_Count;
@dynamic hasLeadingComments, leadingComments;
@dynamic hasTrailingComments, trailingComments;
@dynamic leadingDetachedCommentsArray, leadingDetachedCommentsArray_Count;

typedef struct GPBSourceCodeInfo_Location__storage_ {
  uint32_t _has_storage_[1];
  GPBInt32Array *pathArray;
  GPBInt32Array *spanArray;
  NSString *leadingComments;
  NSString *trailingComments;
  NSMutableArray *leadingDetachedCommentsArray;
} GPBSourceCodeInfo_Location__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBSourceCodeInfo_Location_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo_Location__storage_, pathArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "spanArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBSourceCodeInfo_Location_FieldNumber_SpanArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo_Location__storage_, spanArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "leadingComments",
        .dataTypeSpecific.className = NULL,
        .number = GPBSourceCodeInfo_Location_FieldNumber_LeadingComments,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo_Location__storage_, leadingComments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trailingComments",
        .dataTypeSpecific.className = NULL,
        .number = GPBSourceCodeInfo_Location_FieldNumber_TrailingComments,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo_Location__storage_, trailingComments),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "leadingDetachedCommentsArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBSourceCodeInfo_Location_FieldNumber_LeadingDetachedCommentsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBSourceCodeInfo_Location__storage_, leadingDetachedCommentsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBSourceCodeInfo_Location class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBSourceCodeInfo_Location__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GPBSourceCodeInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBGeneratedCodeInfo

@implementation GPBGeneratedCodeInfo

@dynamic annotationArray, annotationArray_Count;

typedef struct GPBGeneratedCodeInfo__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *annotationArray;
} GPBGeneratedCodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "annotationArray",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBGeneratedCodeInfo_Annotation),
        .number = GPBGeneratedCodeInfo_FieldNumber_AnnotationArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBGeneratedCodeInfo__storage_, annotationArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBGeneratedCodeInfo class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBGeneratedCodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GPBGeneratedCodeInfo_Annotation

@implementation GPBGeneratedCodeInfo_Annotation

@dynamic pathArray, pathArray_Count;
@dynamic hasSourceFile, sourceFile;
@dynamic hasBegin, begin;
@dynamic hasEnd, end;

typedef struct GPBGeneratedCodeInfo_Annotation__storage_ {
  uint32_t _has_storage_[1];
  int32_t begin;
  int32_t end;
  GPBInt32Array *pathArray;
  NSString *sourceFile;
} GPBGeneratedCodeInfo_Annotation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "pathArray",
        .dataTypeSpecific.className = NULL,
        .number = GPBGeneratedCodeInfo_Annotation_FieldNumber_PathArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GPBGeneratedCodeInfo_Annotation__storage_, pathArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sourceFile",
        .dataTypeSpecific.className = NULL,
        .number = GPBGeneratedCodeInfo_Annotation_FieldNumber_SourceFile,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GPBGeneratedCodeInfo_Annotation__storage_, sourceFile),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "begin",
        .dataTypeSpecific.className = NULL,
        .number = GPBGeneratedCodeInfo_Annotation_FieldNumber_Begin,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GPBGeneratedCodeInfo_Annotation__storage_, begin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "end",
        .dataTypeSpecific.className = NULL,
        .number = GPBGeneratedCodeInfo_Annotation_FieldNumber_End,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(GPBGeneratedCodeInfo_Annotation__storage_, end),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GPBGeneratedCodeInfo_Annotation class]
                                     rootClass:[GPBDescriptorRoot class]
                                          file:GPBDescriptorRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GPBGeneratedCodeInfo_Annotation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(GPBGeneratedCodeInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)

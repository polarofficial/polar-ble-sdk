// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pftp_notification.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///
/// Types for device to host notifications (SAGRFC53).
/// Device to host notification parameters, if any, are transmitted in the following
/// data (SAGRFC56) and defined below, individually per notification type.
enum Protocol_PbPFtpDevToHostNotification: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// (Not used currently for anything. Reserved for future use.)
  case filesystemModified // = 0

  /// Used to inform host about internal test data.
  case internalTestEvent // = 1

  /// Used to inform host when the device is ready to communicate again after reporting WAIT_FOR_IDLING error.
  case idling // = 2

  /// Used to inform host about device's battery status.
  case batteryStatus // = 3

  /// Used to inform host about user's inactivity.
  case inactivityAlert // = 4

  /// Used to inform host about training session status.
  case trainingSessionStatus // = 5

  /// Used by device to request host to sync. This happens for example when user presses "Sync" button in the device.
  case syncRequired // = 7

  /// Used by device to inform result of START_AUTOSYNC synchronization.
  case autosyncStatus // = 8

  /// Used to send responses to Polar Notification Service notifications.
  case pnsDhNotificationResponse // = 9

  /// Used for Polar Notification Service settings
  case pnsSettings // = 10

  /// Used to request mobile device to start GPS measurement. Parameter PbPftpStartGPSMeasurement
  case startGpsMeasurement // = 11

  /// Used to request mobile device to stop GPS measurement. No parameters
  case stopGpsMeasurement // = 12

  /// Used to keep mobile running in background. No parameters
  case keepBackgroundAlive // = 13

  /// Polar shell is to transfer any test related data from device to host
  case polarShellDhData // = 14

  /// Request information from media player
  case mediaControlRequestDh // = 15

  /// Send command for media player
  case mediaControlCommandDh // = 16

  /// Used for informing host when device wants to receive media control data
  case mediaControlEnabled // = 17

  /// Generic REST API event
  case restApiEvent // = 18

  /// Used to inform host about exercise status
  case exerciseStatus // = 19

  init() {
    self = .filesystemModified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .filesystemModified
    case 1: self = .internalTestEvent
    case 2: self = .idling
    case 3: self = .batteryStatus
    case 4: self = .inactivityAlert
    case 5: self = .trainingSessionStatus
    case 7: self = .syncRequired
    case 8: self = .autosyncStatus
    case 9: self = .pnsDhNotificationResponse
    case 10: self = .pnsSettings
    case 11: self = .startGpsMeasurement
    case 12: self = .stopGpsMeasurement
    case 13: self = .keepBackgroundAlive
    case 14: self = .polarShellDhData
    case 15: self = .mediaControlRequestDh
    case 16: self = .mediaControlCommandDh
    case 17: self = .mediaControlEnabled
    case 18: self = .restApiEvent
    case 19: self = .exerciseStatus
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .filesystemModified: return 0
    case .internalTestEvent: return 1
    case .idling: return 2
    case .batteryStatus: return 3
    case .inactivityAlert: return 4
    case .trainingSessionStatus: return 5
    case .syncRequired: return 7
    case .autosyncStatus: return 8
    case .pnsDhNotificationResponse: return 9
    case .pnsSettings: return 10
    case .startGpsMeasurement: return 11
    case .stopGpsMeasurement: return 12
    case .keepBackgroundAlive: return 13
    case .polarShellDhData: return 14
    case .mediaControlRequestDh: return 15
    case .mediaControlCommandDh: return 16
    case .mediaControlEnabled: return 17
    case .restApiEvent: return 18
    case .exerciseStatus: return 19
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpDevToHostNotification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Protocol_Action: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case created // = 0
  case updated // = 1
  case removed // = 2

  init() {
    self = .created
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .created
    case 1: self = .updated
    case 2: self = .removed
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .created: return 0
    case .updated: return 1
    case .removed: return 2
    }
  }

}

#if swift(>=4.2)

extension Protocol_Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Protocol_PbPFtpSyncTriggerSource: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case noSource // = 0
  case user // = 1
  case timed // = 2
  case feature // = 3

  init() {
    self = .noSource
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noSource
    case 1: self = .user
    case 2: self = .timed
    case 3: self = .feature
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .noSource: return 0
    case .user: return 1
    case .timed: return 2
    case .feature: return 3
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpSyncTriggerSource: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Protocol_PbPftpPnsDHAttributeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownAction // = 1
  case positiveAction // = 2
  case negativeAction // = 3
  case clearAction // = 4
  case aAction // = 5
  case bAction // = 6
  case cAction // = 7
  case dAction // = 8

  init() {
    self = .unknownAction
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .unknownAction
    case 2: self = .positiveAction
    case 3: self = .negativeAction
    case 4: self = .clearAction
    case 5: self = .aAction
    case 6: self = .bAction
    case 7: self = .cAction
    case 8: self = .dAction
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownAction: return 1
    case .positiveAction: return 2
    case .negativeAction: return 3
    case .clearAction: return 4
    case .aAction: return 5
    case .bAction: return 6
    case .cAction: return 7
    case .dAction: return 8
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsDHAttributeType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for MEDIA_CONTROL_REQUEST_DH
enum Protocol_MediaControlRequest: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Request for MEDIA_DATA_HD
  case getMediaData // = 1

  /// Request for MEDIA_PLAYBACK_STATE_HD
  case getPlaybackState // = 2

  init() {
    self = .getMediaData
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .getMediaData
    case 2: self = .getPlaybackState
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .getMediaData: return 1
    case .getPlaybackState: return 2
    }
  }

}

#if swift(>=4.2)

extension Protocol_MediaControlRequest: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// List of possible DH media control commands. Used in both HD and DH messages
enum Protocol_MediaControlCommand: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case play // = 1
  case pause // = 2
  case togglerPlayPause // = 3
  case next // = 4
  case previous // = 5
  case fastForward // = 6
  case fastBackward // = 7
  case volumeUp // = 8
  case volumeDown // = 9

  init() {
    self = .play
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .play
    case 2: self = .pause
    case 3: self = .togglerPlayPause
    case 4: self = .next
    case 5: self = .previous
    case 6: self = .fastForward
    case 7: self = .fastBackward
    case 8: self = .volumeUp
    case 9: self = .volumeDown
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .play: return 1
    case .pause: return 2
    case .togglerPlayPause: return 3
    case .next: return 4
    case .previous: return 5
    case .fastForward: return 6
    case .fastBackward: return 7
    case .volumeUp: return 8
    case .volumeDown: return 9
    }
  }

}

#if swift(>=4.2)

extension Protocol_MediaControlCommand: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Types for host to device notifications (SAGRFC53).
/// Host to device notification parameters, if any, are transmitted in the following
/// data (SAGRFC56) and defined below, individually per notification type.
enum Protocol_PbPFtpHostToDevNotification: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Instructs device to show syncing animation
  case startSync // = 0

  /// Instructs device to hide syncing animation
  case stopSync // = 1
  case reset // = 2
  case lockProductionData // = 3

  ///Sync terminate notification overrides start and stop sync sequency. 
  ///Device is forced to ignore and terminate running synchonization.
  case terminateSync // = 4

  /// keep alive, mainly for wireless connection to maintain link.
  case keepAlive // = 5

  /// Command the device to perform autosync if the device is able to automatically sync to a web service for instance.
  case startAutosync // = 6
  case pnsHdNotification // = 7

  /// Instructs the device to initialize connection, if necessary.
  case initializeSession // = 8

  /// Instructs the device to terminate connection, if possible.
  case terminateSession // = 9

  /// Instruct the device to simulate button press
  case simulateButtonPress // = 10

  /// Instruct the device to simulate touch screen
  case simulateTouchScreen // = 11

  /// Instructs the device to start sync session, if possible
  case requestSync // = 12

  /// Notify the device that a new firmware is available
  case firmwareUpdateAvailable // = 13

  /// GPS data for device when using mobile as GPS sensor
  case gpsData // = 14

  /// Indication of lost GPS signal for device when using mobile as GPS sensor
  case gpsLost // = 15

  /// User has not given permission to use mobile's GPS sensor
  case gpsNoPermission // = 16

  /// Polar shell is to transfer any test related data from host to device
  case polarShellHdData // = 17

  /// Information about media and media player
  case mediaDataHd // = 18

  /// Playback state of active media
  case mediaPlaybackStateHd // = 19

  init() {
    self = .startSync
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .startSync
    case 1: self = .stopSync
    case 2: self = .reset
    case 3: self = .lockProductionData
    case 4: self = .terminateSync
    case 5: self = .keepAlive
    case 6: self = .startAutosync
    case 7: self = .pnsHdNotification
    case 8: self = .initializeSession
    case 9: self = .terminateSession
    case 10: self = .simulateButtonPress
    case 11: self = .simulateTouchScreen
    case 12: self = .requestSync
    case 13: self = .firmwareUpdateAvailable
    case 14: self = .gpsData
    case 15: self = .gpsLost
    case 16: self = .gpsNoPermission
    case 17: self = .polarShellHdData
    case 18: self = .mediaDataHd
    case 19: self = .mediaPlaybackStateHd
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .startSync: return 0
    case .stopSync: return 1
    case .reset: return 2
    case .lockProductionData: return 3
    case .terminateSync: return 4
    case .keepAlive: return 5
    case .startAutosync: return 6
    case .pnsHdNotification: return 7
    case .initializeSession: return 8
    case .terminateSession: return 9
    case .simulateButtonPress: return 10
    case .simulateTouchScreen: return 11
    case .requestSync: return 12
    case .firmwareUpdateAvailable: return 13
    case .gpsData: return 14
    case .gpsLost: return 15
    case .gpsNoPermission: return 16
    case .polarShellHdData: return 17
    case .mediaDataHd: return 18
    case .mediaPlaybackStateHd: return 19
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPFtpHostToDevNotification: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Protocol_PbPftpPnsHDCategoryID: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case categoryIDOther // = 0
  case categoryIDPolar // = 1
  case categoryIDIncomingcall // = 2
  case categoryIDMissedcall // = 3
  case categoryIDVoicemail // = 4
  case categoryIDSocial // = 5
  case categoryIDSchedule // = 6
  case categoryIDEmail // = 7
  case categoryIDNews // = 8
  case categoryIDHealthandfitness // = 9
  case categoryIDBusinessandfinance // = 10
  case categoryIDLocation // = 11
  case categoryIDEntertainment // = 12

  ///Alarm or timer.
  case categoryIDAlarm // = 13

  ///Promotion or advertisement. 
  case categoryIDPromo // = 14

  ///A specific, timely recommendation for a single thing. 
  case categoryIDRecommendation // = 15

  ///Ongoing information about device or contextual status. 
  case categoryIDStatus // = 16

  ///Media transport control for playback.
  case categoryIDTransport // = 17

  init() {
    self = .categoryIDOther
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .categoryIDOther
    case 1: self = .categoryIDPolar
    case 2: self = .categoryIDIncomingcall
    case 3: self = .categoryIDMissedcall
    case 4: self = .categoryIDVoicemail
    case 5: self = .categoryIDSocial
    case 6: self = .categoryIDSchedule
    case 7: self = .categoryIDEmail
    case 8: self = .categoryIDNews
    case 9: self = .categoryIDHealthandfitness
    case 10: self = .categoryIDBusinessandfinance
    case 11: self = .categoryIDLocation
    case 12: self = .categoryIDEntertainment
    case 13: self = .categoryIDAlarm
    case 14: self = .categoryIDPromo
    case 15: self = .categoryIDRecommendation
    case 16: self = .categoryIDStatus
    case 17: self = .categoryIDTransport
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .categoryIDOther: return 0
    case .categoryIDPolar: return 1
    case .categoryIDIncomingcall: return 2
    case .categoryIDMissedcall: return 3
    case .categoryIDVoicemail: return 4
    case .categoryIDSocial: return 5
    case .categoryIDSchedule: return 6
    case .categoryIDEmail: return 7
    case .categoryIDNews: return 8
    case .categoryIDHealthandfitness: return 9
    case .categoryIDBusinessandfinance: return 10
    case .categoryIDLocation: return 11
    case .categoryIDEntertainment: return 12
    case .categoryIDAlarm: return 13
    case .categoryIDPromo: return 14
    case .categoryIDRecommendation: return 15
    case .categoryIDStatus: return 16
    case .categoryIDTransport: return 17
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsHDCategoryID: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

/// Host to device attribute type 
enum Protocol_PbPftpPnsHDAttributeType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case title // = 0
  case subtitle // = 1
  case message // = 2
  case positiveActionLabel // = 3
  case negativeActionLabel // = 4
  case applicationName // = 5
  case clearActionLabel // = 6
  case aActionLabel // = 7
  case bActionLabel // = 8
  case cActionLabel // = 9
  case dActionLabel // = 10

  init() {
    self = .title
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .title
    case 1: self = .subtitle
    case 2: self = .message
    case 3: self = .positiveActionLabel
    case 4: self = .negativeActionLabel
    case 5: self = .applicationName
    case 6: self = .clearActionLabel
    case 7: self = .aActionLabel
    case 8: self = .bActionLabel
    case 9: self = .cActionLabel
    case 10: self = .dActionLabel
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .title: return 0
    case .subtitle: return 1
    case .message: return 2
    case .positiveActionLabel: return 3
    case .negativeActionLabel: return 4
    case .applicationName: return 5
    case .clearActionLabel: return 6
    case .aActionLabel: return 7
    case .bActionLabel: return 8
    case .cActionLabel: return 9
    case .dActionLabel: return 10
    }
  }

}

#if swift(>=4.2)

extension Protocol_PbPftpPnsHDAttributeType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for MEDIA_PLAYBACK_STATE_HD host to device notification
enum Protocol_PlaybackState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stateNone // = 1
  case stateStopped // = 2
  case statePlaying // = 3
  case statePaused // = 4
  case stateFastForwarding // = 5
  case stateRewinding // = 6
  case stateBuffering // = 7
  case stateError // = 8
  case stateConnecting // = 9
  case stateSkippingToPrevious // = 10
  case stateSkippingToNext // = 11
  case stateSkippingToQueueItem // = 12

  init() {
    self = .stateNone
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .stateNone
    case 2: self = .stateStopped
    case 3: self = .statePlaying
    case 4: self = .statePaused
    case 5: self = .stateFastForwarding
    case 6: self = .stateRewinding
    case 7: self = .stateBuffering
    case 8: self = .stateError
    case 9: self = .stateConnecting
    case 10: self = .stateSkippingToPrevious
    case 11: self = .stateSkippingToNext
    case 12: self = .stateSkippingToQueueItem
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .stateNone: return 1
    case .stateStopped: return 2
    case .statePlaying: return 3
    case .statePaused: return 4
    case .stateFastForwarding: return 5
    case .stateRewinding: return 6
    case .stateBuffering: return 7
    case .stateError: return 8
    case .stateConnecting: return 9
    case .stateSkippingToPrevious: return 10
    case .stateSkippingToNext: return 11
    case .stateSkippingToQueueItem: return 12
    }
  }

}

#if swift(>=4.2)

extension Protocol_PlaybackState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct Protocol_PbPFtpFilesystemModifiedParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Taken action on a file or directory.
  var action: Protocol_Action {
    get {return _action ?? .created}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  /// Path to the file or directory. Ending directory delimiter designates directory. Otherwise the path is considered to refer to a file.
  var path: String {
    get {return _path ?? String()}
    set {_path = newValue}
  }
  /// Returns true if `path` has been explicitly set.
  var hasPath: Bool {return self._path != nil}
  /// Clears the value of `path`. Subsequent reads from it will return its default value.
  mutating func clearPath() {self._path = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _action: Protocol_Action? = nil
  fileprivate var _path: String? = nil
}

///
/// Parameters for INACTIVITY_ALERT device to host notification.
struct Protocol_PbPFtpInactivityAlert {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Countdown to inactivity alert in minutes. 0 means that the alert has been triggered. >0 means pre-alert notification.
  var countdown: UInt32 {
    get {return _countdown ?? 0}
    set {_countdown = newValue}
  }
  /// Returns true if `countdown` has been explicitly set.
  var hasCountdown: Bool {return self._countdown != nil}
  /// Clears the value of `countdown`. Subsequent reads from it will return its default value.
  mutating func clearCountdown() {self._countdown = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _countdown: UInt32? = nil
}

///
/// Parameters for TRAINING_SESSION_STATUS device to host notification.
struct Protocol_PbPFtpTrainingSessionStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, training session is inprogress or was started. False, when training session ended.
  var inprogress: Bool {
    get {return _inprogress ?? false}
    set {_inprogress = newValue}
  }
  /// Returns true if `inprogress` has been explicitly set.
  var hasInprogress: Bool {return self._inprogress != nil}
  /// Clears the value of `inprogress`. Subsequent reads from it will return its default value.
  mutating func clearInprogress() {self._inprogress = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _inprogress: Bool? = nil
}

///
/// Parameters for AUTOSYNC_STATUS device to host notification.
struct Protocol_PbPFtpAutoSyncStatusParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, autosync completed successfully. False, if the synchronization failed.
  var succeeded: Bool {
    get {return _succeeded ?? false}
    set {_succeeded = newValue}
  }
  /// Returns true if `succeeded` has been explicitly set.
  var hasSucceeded: Bool {return self._succeeded != nil}
  /// Clears the value of `succeeded`. Subsequent reads from it will return its default value.
  mutating func clearSucceeded() {self._succeeded = nil}

  ///description of the failed synchronization, TODO define these. One example is timeout.
  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _succeeded: Bool? = nil
  fileprivate var _description_p: String? = nil
}

struct Protocol_PbPFtpSyncTrigger {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Protocol_PbPFtpSyncTriggerSource {
    get {return _source ?? .noSource}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var featureName: String {
    get {return _featureName ?? String()}
    set {_featureName = newValue}
  }
  /// Returns true if `featureName` has been explicitly set.
  var hasFeatureName: Bool {return self._featureName != nil}
  /// Clears the value of `featureName`. Subsequent reads from it will return its default value.
  mutating func clearFeatureName() {self._featureName = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _source: Protocol_PbPFtpSyncTriggerSource? = nil
  fileprivate var _featureName: String? = nil
}

struct Protocol_PbPFtpSyncRequiredParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var syncTriggers: [Protocol_PbPFtpSyncTrigger] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
/// Parameters for Polar shell device to host notification
struct Protocol_PbPFtpPolarShellMessageParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// polar shell message id
  var polarShellMsgID: UInt32 {
    get {return _polarShellMsgID ?? 0}
    set {_polarShellMsgID = newValue}
  }
  /// Returns true if `polarShellMsgID` has been explicitly set.
  var hasPolarShellMsgID: Bool {return self._polarShellMsgID != nil}
  /// Clears the value of `polarShellMsgID`. Subsequent reads from it will return its default value.
  mutating func clearPolarShellMsgID() {self._polarShellMsgID = nil}

  /// optional data for the notification
  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _polarShellMsgID: UInt32? = nil
  fileprivate var _data: String? = nil
}

struct Protocol_PbPftpPnsDHAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Protocol_PbPftpPnsDHAttributeType {
    get {return _type ?? .unknownAction}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Protocol_PbPftpPnsDHAttributeType? = nil
}

struct Protocol_PbPftpPnsDHNotificationResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationID: UInt32 {
    get {return _notificationID ?? 0}
    set {_notificationID = newValue}
  }
  /// Returns true if `notificationID` has been explicitly set.
  var hasNotificationID: Bool {return self._notificationID != nil}
  /// Clears the value of `notificationID`. Subsequent reads from it will return its default value.
  mutating func clearNotificationID() {self._notificationID = nil}

  var attributes: [Protocol_PbPftpPnsDHAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _notificationID: UInt32? = nil
}

struct Protocol_PbPftpPnsState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationsEnabled: Bool {
    get {return _notificationsEnabled ?? false}
    set {_notificationsEnabled = newValue}
  }
  /// Returns true if `notificationsEnabled` has been explicitly set.
  var hasNotificationsEnabled: Bool {return self._notificationsEnabled != nil}
  /// Clears the value of `notificationsEnabled`. Subsequent reads from it will return its default value.
  mutating func clearNotificationsEnabled() {self._notificationsEnabled = nil}

  ///False if not available
  var previewEnabled: Bool {
    get {return _previewEnabled ?? false}
    set {_previewEnabled = newValue}
  }
  /// Returns true if `previewEnabled` has been explicitly set.
  var hasPreviewEnabled: Bool {return self._previewEnabled != nil}
  /// Clears the value of `previewEnabled`. Subsequent reads from it will return its default value.
  mutating func clearPreviewEnabled() {self._previewEnabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _notificationsEnabled: Bool? = nil
  fileprivate var _previewEnabled: Bool? = nil
}

struct Protocol_PbPftpStartGPSMeasurement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum GPS data notification sending interval in milliseconds
  var minimumInterval: UInt32 {
    get {return _minimumInterval ?? 1000}
    set {_minimumInterval = newValue}
  }
  /// Returns true if `minimumInterval` has been explicitly set.
  var hasMinimumInterval: Bool {return self._minimumInterval != nil}
  /// Clears the value of `minimumInterval`. Subsequent reads from it will return its default value.
  mutating func clearMinimumInterval() {self._minimumInterval = nil}

  /// Needed distance increment in meters for sending GPS data notification
  var accuracy: UInt32 {
    get {return _accuracy ?? 2}
    set {_accuracy = newValue}
  }
  /// Returns true if `accuracy` has been explicitly set.
  var hasAccuracy: Bool {return self._accuracy != nil}
  /// Clears the value of `accuracy`. Subsequent reads from it will return its default value.
  mutating func clearAccuracy() {self._accuracy = nil}

  ///latitude (in degrees) of location to start distance cumulation. Leave empty if start location is next availalbe gps location.
  ///value is positive on northern hemisphere
  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  ///Longitude (in degrees) of location to start distance cumulation. Leave empty if start location is next availalbe gps location.
  ///value is positive on northern hemisphere
  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _minimumInterval: UInt32? = nil
  fileprivate var _accuracy: UInt32? = nil
  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
}

struct Protocol_PbPftpDHMediaControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: Protocol_MediaControlRequest {
    get {return _request ?? .getMediaData}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  mutating func clearRequest() {self._request = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _request: Protocol_MediaControlRequest? = nil
}

///
/// Parameters for MEDIA_CONTROL_COMMAND_DH
struct Protocol_PbPftpDHMediaControlCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var command: Protocol_MediaControlCommand {
    get {return _command ?? .play}
    set {_command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return self._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {self._command = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _command: Protocol_MediaControlCommand? = nil
}

///
/// Parameters for MEDIA_CONTROL_ENABLED
struct Protocol_PbPftpDHMediaControlEnabled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var enabled: Bool {
    get {return _enabled ?? false}
    set {_enabled = newValue}
  }
  /// Returns true if `enabled` has been explicitly set.
  var hasEnabled: Bool {return self._enabled != nil}
  /// Clears the value of `enabled`. Subsequent reads from it will return its default value.
  mutating func clearEnabled() {self._enabled = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enabled: Bool? = nil
}

///
/// Parameters for REST_API_EVENT
/// Content is either a plain-text or deflate-compressed JSON message
struct Protocol_PbPftpDHRestApiEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var event: [Data] = []

  /// If this field is missing or false, the payload is compressed
  var uncompressed: Bool {
    get {return _uncompressed ?? false}
    set {_uncompressed = newValue}
  }
  /// Returns true if `uncompressed` has been explicitly set.
  var hasUncompressed: Bool {return self._uncompressed != nil}
  /// Clears the value of `uncompressed`. Subsequent reads from it will return its default value.
  mutating func clearUncompressed() {self._uncompressed = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _uncompressed: Bool? = nil
}

///
/// Parameters for EXERCISE_STATUS
struct Protocol_PbPftpDHExerciseStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exerciseState: Protocol_PbPftpDHExerciseStatus.PbExerciseState {
    get {return _exerciseState ?? .exerciseStateOther}
    set {_exerciseState = newValue}
  }
  /// Returns true if `exerciseState` has been explicitly set.
  var hasExerciseState: Bool {return self._exerciseState != nil}
  /// Clears the value of `exerciseState`. Subsequent reads from it will return its default value.
  mutating func clearExerciseState() {self._exerciseState = nil}

  var exerciseType: Protocol_PbPftpDHExerciseStatus.PbExerciseType {
    get {return _exerciseType ?? .exerciseTypeOther}
    set {_exerciseType = newValue}
  }
  /// Returns true if `exerciseType` has been explicitly set.
  var hasExerciseType: Bool {return self._exerciseType != nil}
  /// Clears the value of `exerciseType`. Subsequent reads from it will return its default value.
  mutating func clearExerciseType() {self._exerciseType = nil}

  var sportIdentifier: PbSportIdentifier {
    get {return _sportIdentifier ?? PbSportIdentifier()}
    set {_sportIdentifier = newValue}
  }
  /// Returns true if `sportIdentifier` has been explicitly set.
  var hasSportIdentifier: Bool {return self._sportIdentifier != nil}
  /// Clears the value of `sportIdentifier`. Subsequent reads from it will return its default value.
  mutating func clearSportIdentifier() {self._sportIdentifier = nil}

  var startTime: PbLocalDateTime {
    get {return _startTime ?? PbLocalDateTime()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {self._startTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbExerciseState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case exerciseStateOther // = 0
    case exerciseStateRunning // = 1
    case exerciseStatePaused // = 2
    case exerciseStateOff // = 3

    init() {
      self = .exerciseStateOther
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .exerciseStateOther
      case 1: self = .exerciseStateRunning
      case 2: self = .exerciseStatePaused
      case 3: self = .exerciseStateOff
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .exerciseStateOther: return 0
      case .exerciseStateRunning: return 1
      case .exerciseStatePaused: return 2
      case .exerciseStateOff: return 3
      }
    }

  }

  enum PbExerciseType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case exerciseTypeOther // = 0
    case exerciseTypeNormal // = 1
    case exerciseTypeRemote // = 2
    case exerciseTypeAutomatic // = 3
    case exerciseTypeDataMerge // = 4

    init() {
      self = .exerciseTypeOther
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .exerciseTypeOther
      case 1: self = .exerciseTypeNormal
      case 2: self = .exerciseTypeRemote
      case 3: self = .exerciseTypeAutomatic
      case 4: self = .exerciseTypeDataMerge
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .exerciseTypeOther: return 0
      case .exerciseTypeNormal: return 1
      case .exerciseTypeRemote: return 2
      case .exerciseTypeAutomatic: return 3
      case .exerciseTypeDataMerge: return 4
      }
    }

  }

  init() {}

  fileprivate var _exerciseState: Protocol_PbPftpDHExerciseStatus.PbExerciseState? = nil
  fileprivate var _exerciseType: Protocol_PbPftpDHExerciseStatus.PbExerciseType? = nil
  fileprivate var _sportIdentifier: PbSportIdentifier? = nil
  fileprivate var _startTime: PbLocalDateTime? = nil
}

#if swift(>=4.2)

extension Protocol_PbPftpDHExerciseStatus.PbExerciseState: CaseIterable {
  // Support synthesized by the compiler.
}

extension Protocol_PbPftpDHExerciseStatus.PbExerciseType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for INITIALIZE_SESSION host to device notification.
struct Protocol_PbInitializeSessionParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// host may give information wheather it uses att level reponse packets from host to device
  var usesAttributeLevelResponse: Bool {
    get {return _usesAttributeLevelResponse ?? false}
    set {_usesAttributeLevelResponse = newValue}
  }
  /// Returns true if `usesAttributeLevelResponse` has been explicitly set.
  var hasUsesAttributeLevelResponse: Bool {return self._usesAttributeLevelResponse != nil}
  /// Clears the value of `usesAttributeLevelResponse`. Subsequent reads from it will return its default value.
  mutating func clearUsesAttributeLevelResponse() {self._usesAttributeLevelResponse = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _usesAttributeLevelResponse: Bool? = nil
}

///
/// Parameters for FIRMWARE_UPDATE_AVAILABLE host to device notification.
struct Protocol_PbFirmwareUpdateAvailableParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Is update mandatory or not
  var mandatory: Bool {
    get {return _mandatory ?? false}
    set {_mandatory = newValue}
  }
  /// Returns true if `mandatory` has been explicitly set.
  var hasMandatory: Bool {return self._mandatory != nil}
  /// Clears the value of `mandatory`. Subsequent reads from it will return its default value.
  mutating func clearMandatory() {self._mandatory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mandatory: Bool? = nil
}

///
/// Parameters for SIMULATE_BUTTON_PRESS host to device notification.
struct Protocol_PbPFtpSimulateButtonPressParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Defines the button to change state
  var button: Buttons {
    get {return _button ?? .buttonPlus}
    set {_button = newValue}
  }
  /// Returns true if `button` has been explicitly set.
  var hasButton: Bool {return self._button != nil}
  /// Clears the value of `button`. Subsequent reads from it will return its default value.
  mutating func clearButton() {self._button = nil}

  /// Defines the new state of button
  var state: ButtonState {
    get {return _state ?? .buttonPressed}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _button: Buttons? = nil
  fileprivate var _state: ButtonState? = nil
}

struct Protocol_PbPFtpTouchPosition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// pixel coordinate if max_pos is not available, otherwise proportional position on display
  var pos: UInt32 {
    get {return _pos ?? 0}
    set {_pos = newValue}
  }
  /// Returns true if `pos` has been explicitly set.
  var hasPos: Bool {return self._pos != nil}
  /// Clears the value of `pos`. Subsequent reads from it will return its default value.
  mutating func clearPos() {self._pos = nil}

  /// maximum position value
  var maxPos: UInt32 {
    get {return _maxPos ?? 0}
    set {_maxPos = newValue}
  }
  /// Returns true if `maxPos` has been explicitly set.
  var hasMaxPos: Bool {return self._maxPos != nil}
  /// Clears the value of `maxPos`. Subsequent reads from it will return its default value.
  mutating func clearMaxPos() {self._maxPos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pos: UInt32? = nil
  fileprivate var _maxPos: UInt32? = nil
}

///
/// Parameters for SIMULATE_TOUCH_SCREEN host to device notification.
struct Protocol_PbPFtpSimulateTouchScreenParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState {
    get {return _state ?? .touchStateStart}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  /// horizontal touch position, available only if touch state is TOUCH_STATE_START or TOUCH_STATE_POSITION
  var xPos: Protocol_PbPFtpTouchPosition {
    get {return _xPos ?? Protocol_PbPFtpTouchPosition()}
    set {_xPos = newValue}
  }
  /// Returns true if `xPos` has been explicitly set.
  var hasXPos: Bool {return self._xPos != nil}
  /// Clears the value of `xPos`. Subsequent reads from it will return its default value.
  mutating func clearXPos() {self._xPos = nil}

  /// vertical touch position, available only if touch state is TOUCH_STATE_START or TOUCH_STATE_POSITION
  var yPos: Protocol_PbPFtpTouchPosition {
    get {return _yPos ?? Protocol_PbPFtpTouchPosition()}
    set {_yPos = newValue}
  }
  /// Returns true if `yPos` has been explicitly set.
  var hasYPos: Bool {return self._yPos != nil}
  /// Clears the value of `yPos`. Subsequent reads from it will return its default value.
  mutating func clearYPos() {self._yPos = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PbPFtpTouchState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// touch started
    case touchStateStart // = 0

    /// touch position update
    case touchStatePosition // = 1

    /// touch ended
    case touchStateEnd // = 2

    init() {
      self = .touchStateStart
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .touchStateStart
      case 1: self = .touchStatePosition
      case 2: self = .touchStateEnd
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .touchStateStart: return 0
      case .touchStatePosition: return 1
      case .touchStateEnd: return 2
      }
    }

  }

  init() {}

  fileprivate var _state: Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState? = nil
  fileprivate var _xPos: Protocol_PbPFtpTouchPosition? = nil
  fileprivate var _yPos: Protocol_PbPFtpTouchPosition? = nil
}

#if swift(>=4.2)

extension Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

///
/// Parameters for STOP_SYNC host to device notification.
struct Protocol_PbPFtpStopSyncParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True if the host considers the synchronization completed, or false if the synchronization was interrupted.
  var completed: Bool {
    get {return _completed ?? false}
    set {_completed = newValue}
  }
  /// Returns true if `completed` has been explicitly set.
  var hasCompleted: Bool {return self._completed != nil}
  /// Clears the value of `completed`. Subsequent reads from it will return its default value.
  mutating func clearCompleted() {self._completed = nil}

  ///description of the failed synchronization
  var description_p: String {
    get {return _description_p ?? String()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _completed: Bool? = nil
  fileprivate var _description_p: String? = nil
}

///
/// Parameters for RESET host to device notification.
struct Protocol_PbPFtpFactoryResetParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If true, the device should go to sleep (shelf/storage mode) after the factory reset. In practice that means
  /// device shutdown; battery consumption is minimized and the device wakeup relies on HW mechanism. Entering
  /// storage mode loses device time.
  var sleep: Bool {
    get {return _sleep ?? false}
    set {_sleep = newValue}
  }
  /// Returns true if `sleep` has been explicitly set.
  var hasSleep: Bool {return self._sleep != nil}
  /// Clears the value of `sleep`. Subsequent reads from it will return its default value.
  mutating func clearSleep() {self._sleep = nil}

  var doFactoryDefaults: Bool {
    get {return _doFactoryDefaults ?? true}
    set {_doFactoryDefaults = newValue}
  }
  /// Returns true if `doFactoryDefaults` has been explicitly set.
  var hasDoFactoryDefaults: Bool {return self._doFactoryDefaults != nil}
  /// Clears the value of `doFactoryDefaults`. Subsequent reads from it will return its default value.
  mutating func clearDoFactoryDefaults() {self._doFactoryDefaults = nil}

  /// bool ota_fwupdate added to be used during firmware update over ble.
  /// for example on Archer, if do_factory_defaults is true and ota_update true, training computer does factory defaults, but
  /// preserves bluetooth pairing info, and establishes the ble connection automatically after reset(long Back-button functionality)
  /// without showing user the "Choose language" -dialog.
  var otaFwupdate: Bool {
    get {return _otaFwupdate ?? false}
    set {_otaFwupdate = newValue}
  }
  /// Returns true if `otaFwupdate` has been explicitly set.
  var hasOtaFwupdate: Bool {return self._otaFwupdate != nil}
  /// Clears the value of `otaFwupdate`. Subsequent reads from it will return its default value.
  mutating func clearOtaFwupdate() {self._otaFwupdate = nil}

  /// If true, the device should go to hibernate instead of the shelf/storage mode. Hibernate consumes slightly
  /// more battery than storage mode, but retains device time. In hibernate battery should last for tens, or even
  /// hundreds of days.
  var hibernate: Bool {
    get {return _hibernate ?? false}
    set {_hibernate = newValue}
  }
  /// Returns true if `hibernate` has been explicitly set.
  var hasHibernate: Bool {return self._hibernate != nil}
  /// Clears the value of `hibernate`. Subsequent reads from it will return its default value.
  mutating func clearHibernate() {self._hibernate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sleep: Bool? = nil
  fileprivate var _doFactoryDefaults: Bool? = nil
  fileprivate var _otaFwupdate: Bool? = nil
  fileprivate var _hibernate: Bool? = nil
}

///
/// Parameters for START_AUTOSYNC host to device notification.
struct Protocol_PbPFtpStartAutosyncParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///device will try connection for time defined in timeout
  var timeout: UInt32 {
    get {return _timeout ?? 0}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeout: UInt32? = nil
}

/// Host to device notification attribute 
struct Protocol_PbPftpPnsHDAttribute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Protocol_PbPftpPnsHDAttributeType {
    get {return _type ?? .title}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var data: String {
    get {return _data ?? String()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  ///
  /// Used to send total length of attribute data.
  /// Eg when we receive just part of email this is used to store total length of mail.
  var attributeFullSize: UInt32 {
    get {return _attributeFullSize ?? 0}
    set {_attributeFullSize = newValue}
  }
  /// Returns true if `attributeFullSize` has been explicitly set.
  var hasAttributeFullSize: Bool {return self._attributeFullSize != nil}
  /// Clears the value of `attributeFullSize`. Subsequent reads from it will return its default value.
  mutating func clearAttributeFullSize() {self._attributeFullSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: Protocol_PbPftpPnsHDAttributeType? = nil
  fileprivate var _data: String? = nil
  fileprivate var _attributeFullSize: UInt32? = nil
}

struct Protocol_PbPftpPnsHDNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var notificationID: UInt32 {
    get {return _notificationID ?? 0}
    set {_notificationID = newValue}
  }
  /// Returns true if `notificationID` has been explicitly set.
  var hasNotificationID: Bool {return self._notificationID != nil}
  /// Clears the value of `notificationID`. Subsequent reads from it will return its default value.
  mutating func clearNotificationID() {self._notificationID = nil}

  var categoryID: Protocol_PbPftpPnsHDCategoryID {
    get {return _categoryID ?? .categoryIDOther}
    set {_categoryID = newValue}
  }
  /// Returns true if `categoryID` has been explicitly set.
  var hasCategoryID: Bool {return self._categoryID != nil}
  /// Clears the value of `categoryID`. Subsequent reads from it will return its default value.
  mutating func clearCategoryID() {self._categoryID = nil}

  var action: Protocol_Action {
    get {return _action ?? .created}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var issueTime: PbLocalDateTime {
    get {return _issueTime ?? PbLocalDateTime()}
    set {_issueTime = newValue}
  }
  /// Returns true if `issueTime` has been explicitly set.
  var hasIssueTime: Bool {return self._issueTime != nil}
  /// Clears the value of `issueTime`. Subsequent reads from it will return its default value.
  mutating func clearIssueTime() {self._issueTime = nil}

  var newSameCategoryNotifications: UInt32 {
    get {return _newSameCategoryNotifications ?? 0}
    set {_newSameCategoryNotifications = newValue}
  }
  /// Returns true if `newSameCategoryNotifications` has been explicitly set.
  var hasNewSameCategoryNotifications: Bool {return self._newSameCategoryNotifications != nil}
  /// Clears the value of `newSameCategoryNotifications`. Subsequent reads from it will return its default value.
  mutating func clearNewSameCategoryNotifications() {self._newSameCategoryNotifications = nil}

  var unreadSameCategoryNotifications: UInt32 {
    get {return _unreadSameCategoryNotifications ?? 0}
    set {_unreadSameCategoryNotifications = newValue}
  }
  /// Returns true if `unreadSameCategoryNotifications` has been explicitly set.
  var hasUnreadSameCategoryNotifications: Bool {return self._unreadSameCategoryNotifications != nil}
  /// Clears the value of `unreadSameCategoryNotifications`. Subsequent reads from it will return its default value.
  mutating func clearUnreadSameCategoryNotifications() {self._unreadSameCategoryNotifications = nil}

  var attributes: [Protocol_PbPftpPnsHDAttribute] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _notificationID: UInt32? = nil
  fileprivate var _categoryID: Protocol_PbPftpPnsHDCategoryID? = nil
  fileprivate var _action: Protocol_Action? = nil
  fileprivate var _issueTime: PbLocalDateTime? = nil
  fileprivate var _newSameCategoryNotifications: UInt32? = nil
  fileprivate var _unreadSameCategoryNotifications: UInt32? = nil
}

///
/// Parameters for GPS_DATA host to device notification.
struct Protocol_PbPFtpGPSDataParams {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// latitude in degrees, value is positive on northern hemisphere
  var latitude: Double {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  /// longitude in degrees, value is positive on eastern hemisphere
  var longitude: Double {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  /// total distance since receiving of START_GPS_MEASUREMENT message
  var distance: Float {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {self._distance = nil}

  var altitude: Float {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  /// number of satellites
  var satelliteAmount: UInt32 {
    get {return _satelliteAmount ?? 0}
    set {_satelliteAmount = newValue}
  }
  /// Returns true if `satelliteAmount` has been explicitly set.
  var hasSatelliteAmount: Bool {return self._satelliteAmount != nil}
  /// Clears the value of `satelliteAmount`. Subsequent reads from it will return its default value.
  mutating func clearSatelliteAmount() {self._satelliteAmount = nil}

  /// Time offset in relation to start time of GPS measurement
  /// range [0 - 359999999] (ms), i.e. 00:00:00.000 - 99:59:59.999
  var timeOffset: UInt32 {
    get {return _timeOffset ?? 0}
    set {_timeOffset = newValue}
  }
  /// Returns true if `timeOffset` has been explicitly set.
  var hasTimeOffset: Bool {return self._timeOffset != nil}
  /// Clears the value of `timeOffset`. Subsequent reads from it will return its default value.
  mutating func clearTimeOffset() {self._timeOffset = nil}

  /// Horizontal accuracy in meters
  var horizontalAccuracy: Float {
    get {return _horizontalAccuracy ?? 0}
    set {_horizontalAccuracy = newValue}
  }
  /// Returns true if `horizontalAccuracy` has been explicitly set.
  var hasHorizontalAccuracy: Bool {return self._horizontalAccuracy != nil}
  /// Clears the value of `horizontalAccuracy`. Subsequent reads from it will return its default value.
  mutating func clearHorizontalAccuracy() {self._horizontalAccuracy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _latitude: Double? = nil
  fileprivate var _longitude: Double? = nil
  fileprivate var _speed: Float? = nil
  fileprivate var _distance: Float? = nil
  fileprivate var _altitude: Float? = nil
  fileprivate var _satelliteAmount: UInt32? = nil
  fileprivate var _timeOffset: UInt32? = nil
  fileprivate var _horizontalAccuracy: Float? = nil
}

///
/// Parameters for MEDIA_DATA_HD host to device notification
struct Protocol_PbPFtpHDMediaData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Available commands
  var commands: [Protocol_MediaControlCommand] = []

  /// Name of media player
  var playerName: String {
    get {return _playerName ?? String()}
    set {_playerName = newValue}
  }
  /// Returns true if `playerName` has been explicitly set.
  var hasPlayerName: Bool {return self._playerName != nil}
  /// Clears the value of `playerName`. Subsequent reads from it will return its default value.
  mutating func clearPlayerName() {self._playerName = nil}

  /// Current artist name
  var artistName: String {
    get {return _artistName ?? String()}
    set {_artistName = newValue}
  }
  /// Returns true if `artistName` has been explicitly set.
  var hasArtistName: Bool {return self._artistName != nil}
  /// Clears the value of `artistName`. Subsequent reads from it will return its default value.
  mutating func clearArtistName() {self._artistName = nil}

  /// Current track name
  var trackName: String {
    get {return _trackName ?? String()}
    set {_trackName = newValue}
  }
  /// Returns true if `trackName` has been explicitly set.
  var hasTrackName: Bool {return self._trackName != nil}
  /// Clears the value of `trackName`. Subsequent reads from it will return its default value.
  mutating func clearTrackName() {self._trackName = nil}

  /// Whole duration of track as seconds
  var trackDuration: Float {
    get {return _trackDuration ?? 0}
    set {_trackDuration = newValue}
  }
  /// Returns true if `trackDuration` has been explicitly set.
  var hasTrackDuration: Bool {return self._trackDuration != nil}
  /// Clears the value of `trackDuration`. Subsequent reads from it will return its default value.
  mutating func clearTrackDuration() {self._trackDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playerName: String? = nil
  fileprivate var _artistName: String? = nil
  fileprivate var _trackName: String? = nil
  fileprivate var _trackDuration: Float? = nil
}

struct Protocol_PbPFtpHDMediaControlPlaybackState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current playback state of media
  var playbackState: Protocol_PlaybackState {
    get {return _playbackState ?? .stateNone}
    set {_playbackState = newValue}
  }
  /// Returns true if `playbackState` has been explicitly set.
  var hasPlaybackState: Bool {return self._playbackState != nil}
  /// Clears the value of `playbackState`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackState() {self._playbackState = nil}

  /// Speed of playing. 1.0 means normal speed
  var playbackRate: Float {
    get {return _playbackRate ?? 0}
    set {_playbackRate = newValue}
  }
  /// Returns true if `playbackRate` has been explicitly set.
  var hasPlaybackRate: Bool {return self._playbackRate != nil}
  /// Clears the value of `playbackRate`. Subsequent reads from it will return its default value.
  mutating func clearPlaybackRate() {self._playbackRate = nil}

  /// Time from start of track to current position as seconds
  var elapsedTime: Float {
    get {return _elapsedTime ?? 0}
    set {_elapsedTime = newValue}
  }
  /// Returns true if `elapsedTime` has been explicitly set.
  var hasElapsedTime: Bool {return self._elapsedTime != nil}
  /// Clears the value of `elapsedTime`. Subsequent reads from it will return its default value.
  mutating func clearElapsedTime() {self._elapsedTime = nil}

  /// Current volume of device. Units percentage value 0-100
  var volumeLevel: UInt32 {
    get {return _volumeLevel ?? 0}
    set {_volumeLevel = newValue}
  }
  /// Returns true if `volumeLevel` has been explicitly set.
  var hasVolumeLevel: Bool {return self._volumeLevel != nil}
  /// Clears the value of `volumeLevel`. Subsequent reads from it will return its default value.
  mutating func clearVolumeLevel() {self._volumeLevel = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _playbackState: Protocol_PlaybackState? = nil
  fileprivate var _playbackRate: Float? = nil
  fileprivate var _elapsedTime: Float? = nil
  fileprivate var _volumeLevel: UInt32? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Protocol_PbPFtpDevToHostNotification: @unchecked Sendable {}
extension Protocol_Action: @unchecked Sendable {}
extension Protocol_PbPFtpSyncTriggerSource: @unchecked Sendable {}
extension Protocol_PbPftpPnsDHAttributeType: @unchecked Sendable {}
extension Protocol_MediaControlRequest: @unchecked Sendable {}
extension Protocol_MediaControlCommand: @unchecked Sendable {}
extension Protocol_PbPFtpHostToDevNotification: @unchecked Sendable {}
extension Protocol_PbPftpPnsHDCategoryID: @unchecked Sendable {}
extension Protocol_PbPftpPnsHDAttributeType: @unchecked Sendable {}
extension Protocol_PlaybackState: @unchecked Sendable {}
extension Protocol_PbPFtpFilesystemModifiedParams: @unchecked Sendable {}
extension Protocol_PbPFtpInactivityAlert: @unchecked Sendable {}
extension Protocol_PbPFtpTrainingSessionStatus: @unchecked Sendable {}
extension Protocol_PbPFtpAutoSyncStatusParams: @unchecked Sendable {}
extension Protocol_PbPFtpSyncTrigger: @unchecked Sendable {}
extension Protocol_PbPFtpSyncRequiredParams: @unchecked Sendable {}
extension Protocol_PbPFtpPolarShellMessageParams: @unchecked Sendable {}
extension Protocol_PbPftpPnsDHAttribute: @unchecked Sendable {}
extension Protocol_PbPftpPnsDHNotificationResponse: @unchecked Sendable {}
extension Protocol_PbPftpPnsState: @unchecked Sendable {}
extension Protocol_PbPftpStartGPSMeasurement: @unchecked Sendable {}
extension Protocol_PbPftpDHMediaControlRequest: @unchecked Sendable {}
extension Protocol_PbPftpDHMediaControlCommand: @unchecked Sendable {}
extension Protocol_PbPftpDHMediaControlEnabled: @unchecked Sendable {}
extension Protocol_PbPftpDHRestApiEvent: @unchecked Sendable {}
extension Protocol_PbPftpDHExerciseStatus: @unchecked Sendable {}
extension Protocol_PbPftpDHExerciseStatus.PbExerciseState: @unchecked Sendable {}
extension Protocol_PbPftpDHExerciseStatus.PbExerciseType: @unchecked Sendable {}
extension Protocol_PbInitializeSessionParams: @unchecked Sendable {}
extension Protocol_PbFirmwareUpdateAvailableParams: @unchecked Sendable {}
extension Protocol_PbPFtpSimulateButtonPressParams: @unchecked Sendable {}
extension Protocol_PbPFtpTouchPosition: @unchecked Sendable {}
extension Protocol_PbPFtpSimulateTouchScreenParams: @unchecked Sendable {}
extension Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState: @unchecked Sendable {}
extension Protocol_PbPFtpStopSyncParams: @unchecked Sendable {}
extension Protocol_PbPFtpFactoryResetParams: @unchecked Sendable {}
extension Protocol_PbPFtpStartAutosyncParams: @unchecked Sendable {}
extension Protocol_PbPftpPnsHDAttribute: @unchecked Sendable {}
extension Protocol_PbPftpPnsHDNotification: @unchecked Sendable {}
extension Protocol_PbPFtpGPSDataParams: @unchecked Sendable {}
extension Protocol_PbPFtpHDMediaData: @unchecked Sendable {}
extension Protocol_PbPFtpHDMediaControlPlaybackState: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_PbPFtpDevToHostNotification: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FILESYSTEM_MODIFIED"),
    1: .same(proto: "INTERNAL_TEST_EVENT"),
    2: .same(proto: "IDLING"),
    3: .same(proto: "BATTERY_STATUS"),
    4: .same(proto: "INACTIVITY_ALERT"),
    5: .same(proto: "TRAINING_SESSION_STATUS"),
    7: .same(proto: "SYNC_REQUIRED"),
    8: .same(proto: "AUTOSYNC_STATUS"),
    9: .same(proto: "PNS_DH_NOTIFICATION_RESPONSE"),
    10: .same(proto: "PNS_SETTINGS"),
    11: .same(proto: "START_GPS_MEASUREMENT"),
    12: .same(proto: "STOP_GPS_MEASUREMENT"),
    13: .same(proto: "KEEP_BACKGROUND_ALIVE"),
    14: .same(proto: "POLAR_SHELL_DH_DATA"),
    15: .same(proto: "MEDIA_CONTROL_REQUEST_DH"),
    16: .same(proto: "MEDIA_CONTROL_COMMAND_DH"),
    17: .same(proto: "MEDIA_CONTROL_ENABLED"),
    18: .same(proto: "REST_API_EVENT"),
    19: .same(proto: "EXERCISE_STATUS"),
  ]
}

extension Protocol_Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CREATED"),
    1: .same(proto: "UPDATED"),
    2: .same(proto: "REMOVED"),
  ]
}

extension Protocol_PbPFtpSyncTriggerSource: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_SOURCE"),
    1: .same(proto: "USER"),
    2: .same(proto: "TIMED"),
    3: .same(proto: "FEATURE"),
  ]
}

extension Protocol_PbPftpPnsDHAttributeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UNKNOWN_ACTION"),
    2: .same(proto: "POSITIVE_ACTION"),
    3: .same(proto: "NEGATIVE_ACTION"),
    4: .same(proto: "CLEAR_ACTION"),
    5: .same(proto: "A_ACTION"),
    6: .same(proto: "B_ACTION"),
    7: .same(proto: "C_ACTION"),
    8: .same(proto: "D_ACTION"),
  ]
}

extension Protocol_MediaControlRequest: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "GET_MEDIA_DATA"),
    2: .same(proto: "GET_PLAYBACK_STATE"),
  ]
}

extension Protocol_MediaControlCommand: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "PLAY"),
    2: .same(proto: "PAUSE"),
    3: .same(proto: "TOGGLER_PLAY_PAUSE"),
    4: .same(proto: "NEXT"),
    5: .same(proto: "PREVIOUS"),
    6: .same(proto: "FAST_FORWARD"),
    7: .same(proto: "FAST_BACKWARD"),
    8: .same(proto: "VOLUME_UP"),
    9: .same(proto: "VOLUME_DOWN"),
  ]
}

extension Protocol_PbPFtpHostToDevNotification: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "START_SYNC"),
    1: .same(proto: "STOP_SYNC"),
    2: .same(proto: "RESET"),
    3: .same(proto: "LOCK_PRODUCTION_DATA"),
    4: .same(proto: "TERMINATE_SYNC"),
    5: .same(proto: "KEEP_ALIVE"),
    6: .same(proto: "START_AUTOSYNC"),
    7: .same(proto: "PNS_HD_NOTIFICATION"),
    8: .same(proto: "INITIALIZE_SESSION"),
    9: .same(proto: "TERMINATE_SESSION"),
    10: .same(proto: "SIMULATE_BUTTON_PRESS"),
    11: .same(proto: "SIMULATE_TOUCH_SCREEN"),
    12: .same(proto: "REQUEST_SYNC"),
    13: .same(proto: "FIRMWARE_UPDATE_AVAILABLE"),
    14: .same(proto: "GPS_DATA"),
    15: .same(proto: "GPS_LOST"),
    16: .same(proto: "GPS_NO_PERMISSION"),
    17: .same(proto: "POLAR_SHELL_HD_DATA"),
    18: .same(proto: "MEDIA_DATA_HD"),
    19: .same(proto: "MEDIA_PLAYBACK_STATE_HD"),
  ]
}

extension Protocol_PbPftpPnsHDCategoryID: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "CATEGORY_ID_OTHER"),
    1: .same(proto: "CATEGORY_ID_POLAR"),
    2: .same(proto: "CATEGORY_ID_INCOMINGCALL"),
    3: .same(proto: "CATEGORY_ID_MISSEDCALL"),
    4: .same(proto: "CATEGORY_ID_VOICEMAIL"),
    5: .same(proto: "CATEGORY_ID_SOCIAL"),
    6: .same(proto: "CATEGORY_ID_SCHEDULE"),
    7: .same(proto: "CATEGORY_ID_EMAIL"),
    8: .same(proto: "CATEGORY_ID_NEWS"),
    9: .same(proto: "CATEGORY_ID_HEALTHANDFITNESS"),
    10: .same(proto: "CATEGORY_ID_BUSINESSANDFINANCE"),
    11: .same(proto: "CATEGORY_ID_LOCATION"),
    12: .same(proto: "CATEGORY_ID_ENTERTAINMENT"),
    13: .same(proto: "CATEGORY_ID_ALARM"),
    14: .same(proto: "CATEGORY_ID_PROMO"),
    15: .same(proto: "CATEGORY_ID_RECOMMENDATION"),
    16: .same(proto: "CATEGORY_ID_STATUS"),
    17: .same(proto: "CATEGORY_ID_TRANSPORT"),
  ]
}

extension Protocol_PbPftpPnsHDAttributeType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TITLE"),
    1: .same(proto: "SUBTITLE"),
    2: .same(proto: "MESSAGE"),
    3: .same(proto: "POSITIVE_ACTION_LABEL"),
    4: .same(proto: "NEGATIVE_ACTION_LABEL"),
    5: .same(proto: "APPLICATION_NAME"),
    6: .same(proto: "CLEAR_ACTION_LABEL"),
    7: .same(proto: "A_ACTION_LABEL"),
    8: .same(proto: "B_ACTION_LABEL"),
    9: .same(proto: "C_ACTION_LABEL"),
    10: .same(proto: "D_ACTION_LABEL"),
  ]
}

extension Protocol_PlaybackState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "STATE_NONE"),
    2: .same(proto: "STATE_STOPPED"),
    3: .same(proto: "STATE_PLAYING"),
    4: .same(proto: "STATE_PAUSED"),
    5: .same(proto: "STATE_FAST_FORWARDING"),
    6: .same(proto: "STATE_REWINDING"),
    7: .same(proto: "STATE_BUFFERING"),
    8: .same(proto: "STATE_ERROR"),
    9: .same(proto: "STATE_CONNECTING"),
    10: .same(proto: "STATE_SKIPPING_TO_PREVIOUS"),
    11: .same(proto: "STATE_SKIPPING_TO_NEXT"),
    12: .same(proto: "STATE_SKIPPING_TO_QUEUE_ITEM"),
  ]
}

extension Protocol_PbPFtpFilesystemModifiedParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpFilesystemModifiedParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "path"),
  ]

  public var isInitialized: Bool {
    if self._action == nil {return false}
    if self._path == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._path {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpFilesystemModifiedParams, rhs: Protocol_PbPFtpFilesystemModifiedParams) -> Bool {
    if lhs._action != rhs._action {return false}
    if lhs._path != rhs._path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpInactivityAlert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpInactivityAlert"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "countdown"),
  ]

  public var isInitialized: Bool {
    if self._countdown == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._countdown) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._countdown {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpInactivityAlert, rhs: Protocol_PbPFtpInactivityAlert) -> Bool {
    if lhs._countdown != rhs._countdown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpTrainingSessionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpTrainingSessionStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inprogress"),
  ]

  public var isInitialized: Bool {
    if self._inprogress == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._inprogress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._inprogress {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpTrainingSessionStatus, rhs: Protocol_PbPFtpTrainingSessionStatus) -> Bool {
    if lhs._inprogress != rhs._inprogress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpAutoSyncStatusParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpAutoSyncStatusParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "succeeded"),
    2: .same(proto: "description"),
  ]

  public var isInitialized: Bool {
    if self._succeeded == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._succeeded) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._succeeded {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpAutoSyncStatusParams, rhs: Protocol_PbPFtpAutoSyncStatusParams) -> Bool {
    if lhs._succeeded != rhs._succeeded {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSyncTrigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSyncTrigger"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "source"),
    2: .standard(proto: "feature_name"),
  ]

  public var isInitialized: Bool {
    if self._source == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._source) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._featureName) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._source {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._featureName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSyncTrigger, rhs: Protocol_PbPFtpSyncTrigger) -> Bool {
    if lhs._source != rhs._source {return false}
    if lhs._featureName != rhs._featureName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSyncRequiredParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSyncRequiredParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sync_triggers"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.syncTriggers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.syncTriggers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.syncTriggers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.syncTriggers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSyncRequiredParams, rhs: Protocol_PbPFtpSyncRequiredParams) -> Bool {
    if lhs.syncTriggers != rhs.syncTriggers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpPolarShellMessageParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpPolarShellMessageParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "polarShellMsgId"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._polarShellMsgID == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._polarShellMsgID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._polarShellMsgID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpPolarShellMessageParams, rhs: Protocol_PbPFtpPolarShellMessageParams) -> Bool {
    if lhs._polarShellMsgID != rhs._polarShellMsgID {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsDHAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPnsDHAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPnsDHAttribute, rhs: Protocol_PbPftpPnsDHAttribute) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsDHNotificationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPnsDHNotificationResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_id"),
    2: .same(proto: "attributes"),
  ]

  public var isInitialized: Bool {
    if self._notificationID == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._notificationID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPnsDHNotificationResponse, rhs: Protocol_PbPftpPnsDHNotificationResponse) -> Bool {
    if lhs._notificationID != rhs._notificationID {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPnsState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notifications_enabled"),
    2: .standard(proto: "preview_enabled"),
  ]

  public var isInitialized: Bool {
    if self._notificationsEnabled == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._notificationsEnabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._previewEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationsEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previewEnabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPnsState, rhs: Protocol_PbPftpPnsState) -> Bool {
    if lhs._notificationsEnabled != rhs._notificationsEnabled {return false}
    if lhs._previewEnabled != rhs._previewEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpStartGPSMeasurement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpStartGPSMeasurement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "minimum_interval"),
    2: .same(proto: "accuracy"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._minimumInterval) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._accuracy) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._minimumInterval {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._accuracy {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpStartGPSMeasurement, rhs: Protocol_PbPftpStartGPSMeasurement) -> Bool {
    if lhs._minimumInterval != rhs._minimumInterval {return false}
    if lhs._accuracy != rhs._accuracy {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHMediaControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpDHMediaControlRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
  ]

  public var isInitialized: Bool {
    if self._request == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._request) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpDHMediaControlRequest, rhs: Protocol_PbPftpDHMediaControlRequest) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHMediaControlCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpDHMediaControlCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
  ]

  public var isInitialized: Bool {
    if self._command == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._command) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._command {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpDHMediaControlCommand, rhs: Protocol_PbPftpDHMediaControlCommand) -> Bool {
    if lhs._command != rhs._command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHMediaControlEnabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpDHMediaControlEnabled"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enabled"),
  ]

  public var isInitialized: Bool {
    if self._enabled == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enabled {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpDHMediaControlEnabled, rhs: Protocol_PbPftpDHMediaControlEnabled) -> Bool {
    if lhs._enabled != rhs._enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHRestApiEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpDHRestApiEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "event"),
    2: .same(proto: "uncompressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedBytesField(value: &self.event) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._uncompressed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.event.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.event, fieldNumber: 1)
    }
    try { if let v = self._uncompressed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpDHRestApiEvent, rhs: Protocol_PbPftpDHRestApiEvent) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs._uncompressed != rhs._uncompressed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHExerciseStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpDHExerciseStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exercise_state"),
    2: .standard(proto: "exercise_type"),
    3: .standard(proto: "sport_identifier"),
    4: .standard(proto: "start_time"),
  ]

  public var isInitialized: Bool {
    if self._exerciseState == nil {return false}
    if let v = self._sportIdentifier, !v.isInitialized {return false}
    if let v = self._startTime, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._exerciseState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._exerciseType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sportIdentifier) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._exerciseState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._exerciseType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sportIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpDHExerciseStatus, rhs: Protocol_PbPftpDHExerciseStatus) -> Bool {
    if lhs._exerciseState != rhs._exerciseState {return false}
    if lhs._exerciseType != rhs._exerciseType {return false}
    if lhs._sportIdentifier != rhs._sportIdentifier {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpDHExerciseStatus.PbExerciseState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXERCISE_STATE_OTHER"),
    1: .same(proto: "EXERCISE_STATE_RUNNING"),
    2: .same(proto: "EXERCISE_STATE_PAUSED"),
    3: .same(proto: "EXERCISE_STATE_OFF"),
  ]
}

extension Protocol_PbPftpDHExerciseStatus.PbExerciseType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "EXERCISE_TYPE_OTHER"),
    1: .same(proto: "EXERCISE_TYPE_NORMAL"),
    2: .same(proto: "EXERCISE_TYPE_REMOTE"),
    3: .same(proto: "EXERCISE_TYPE_AUTOMATIC"),
    4: .same(proto: "EXERCISE_TYPE_DATA_MERGE"),
  ]
}

extension Protocol_PbInitializeSessionParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbInitializeSessionParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "uses_attribute_level_response"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._usesAttributeLevelResponse) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._usesAttributeLevelResponse {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbInitializeSessionParams, rhs: Protocol_PbInitializeSessionParams) -> Bool {
    if lhs._usesAttributeLevelResponse != rhs._usesAttributeLevelResponse {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbFirmwareUpdateAvailableParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbFirmwareUpdateAvailableParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mandatory"),
  ]

  public var isInitialized: Bool {
    if self._mandatory == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._mandatory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mandatory {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbFirmwareUpdateAvailableParams, rhs: Protocol_PbFirmwareUpdateAvailableParams) -> Bool {
    if lhs._mandatory != rhs._mandatory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateButtonPressParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSimulateButtonPressParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "button"),
    2: .same(proto: "state"),
  ]

  public var isInitialized: Bool {
    if self._button == nil {return false}
    if self._state == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._button) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._button {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSimulateButtonPressParams, rhs: Protocol_PbPFtpSimulateButtonPressParams) -> Bool {
    if lhs._button != rhs._button {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpTouchPosition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpTouchPosition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pos"),
    2: .standard(proto: "max_pos"),
  ]

  public var isInitialized: Bool {
    if self._pos == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._pos) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._maxPos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pos {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._maxPos {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpTouchPosition, rhs: Protocol_PbPFtpTouchPosition) -> Bool {
    if lhs._pos != rhs._pos {return false}
    if lhs._maxPos != rhs._maxPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateTouchScreenParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpSimulateTouchScreenParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "x_pos"),
    3: .standard(proto: "y_pos"),
  ]

  public var isInitialized: Bool {
    if self._state == nil {return false}
    if let v = self._xPos, !v.isInitialized {return false}
    if let v = self._yPos, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._xPos) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._yPos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._xPos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._yPos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpSimulateTouchScreenParams, rhs: Protocol_PbPFtpSimulateTouchScreenParams) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs._xPos != rhs._xPos {return false}
    if lhs._yPos != rhs._yPos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpSimulateTouchScreenParams.PbPFtpTouchState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TOUCH_STATE_START"),
    1: .same(proto: "TOUCH_STATE_POSITION"),
    2: .same(proto: "TOUCH_STATE_END"),
  ]
}

extension Protocol_PbPFtpStopSyncParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpStopSyncParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "completed"),
    2: .same(proto: "description"),
  ]

  public var isInitialized: Bool {
    if self._completed == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._completed) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._completed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._description_p {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpStopSyncParams, rhs: Protocol_PbPFtpStopSyncParams) -> Bool {
    if lhs._completed != rhs._completed {return false}
    if lhs._description_p != rhs._description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpFactoryResetParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpFactoryResetParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sleep"),
    2: .standard(proto: "do_factory_defaults"),
    3: .standard(proto: "ota_fwupdate"),
    4: .same(proto: "hibernate"),
  ]

  public var isInitialized: Bool {
    if self._sleep == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._sleep) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._doFactoryDefaults) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._otaFwupdate) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._hibernate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sleep {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._doFactoryDefaults {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._otaFwupdate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hibernate {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpFactoryResetParams, rhs: Protocol_PbPFtpFactoryResetParams) -> Bool {
    if lhs._sleep != rhs._sleep {return false}
    if lhs._doFactoryDefaults != rhs._doFactoryDefaults {return false}
    if lhs._otaFwupdate != rhs._otaFwupdate {return false}
    if lhs._hibernate != rhs._hibernate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpStartAutosyncParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpStartAutosyncParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timeout"),
  ]

  public var isInitialized: Bool {
    if self._timeout == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._timeout) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeout {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpStartAutosyncParams, rhs: Protocol_PbPFtpStartAutosyncParams) -> Bool {
    if lhs._timeout != rhs._timeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsHDAttribute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPnsHDAttribute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "data"),
    3: .standard(proto: "attribute_full_size"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._attributeFullSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._attributeFullSize {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPnsHDAttribute, rhs: Protocol_PbPftpPnsHDAttribute) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._data != rhs._data {return false}
    if lhs._attributeFullSize != rhs._attributeFullSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPftpPnsHDNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPftpPnsHDNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "notification_id"),
    2: .standard(proto: "category_id"),
    3: .same(proto: "action"),
    4: .standard(proto: "issue_time"),
    5: .standard(proto: "new_same_category_notifications"),
    6: .standard(proto: "unread_same_category_notifications"),
    7: .same(proto: "attributes"),
  ]

  public var isInitialized: Bool {
    if self._notificationID == nil {return false}
    if self._categoryID == nil {return false}
    if self._action == nil {return false}
    if self._issueTime == nil {return false}
    if let v = self._issueTime, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attributes) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._notificationID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._categoryID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._issueTime) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._newSameCategoryNotifications) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._unreadSameCategoryNotifications) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.attributes) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._notificationID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._categoryID {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._issueTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._newSameCategoryNotifications {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._unreadSameCategoryNotifications {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    if !self.attributes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attributes, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPftpPnsHDNotification, rhs: Protocol_PbPftpPnsHDNotification) -> Bool {
    if lhs._notificationID != rhs._notificationID {return false}
    if lhs._categoryID != rhs._categoryID {return false}
    if lhs._action != rhs._action {return false}
    if lhs._issueTime != rhs._issueTime {return false}
    if lhs._newSameCategoryNotifications != rhs._newSameCategoryNotifications {return false}
    if lhs._unreadSameCategoryNotifications != rhs._unreadSameCategoryNotifications {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpGPSDataParams: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpGPSDataParams"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
    3: .same(proto: "speed"),
    4: .same(proto: "distance"),
    5: .same(proto: "altitude"),
    6: .standard(proto: "satellite_amount"),
    7: .standard(proto: "time_offset"),
    8: .standard(proto: "horizontal_accuracy"),
  ]

  public var isInitialized: Bool {
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self._latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self._longitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._speed) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._distance) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._altitude) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._satelliteAmount) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._timeOffset) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self._horizontalAccuracy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._latitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._altitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._satelliteAmount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._timeOffset {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._horizontalAccuracy {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpGPSDataParams, rhs: Protocol_PbPFtpGPSDataParams) -> Bool {
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._satelliteAmount != rhs._satelliteAmount {return false}
    if lhs._timeOffset != rhs._timeOffset {return false}
    if lhs._horizontalAccuracy != rhs._horizontalAccuracy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpHDMediaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpHDMediaData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "commands"),
    2: .same(proto: "playerName"),
    3: .same(proto: "artistName"),
    4: .same(proto: "trackName"),
    5: .standard(proto: "track_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedEnumField(value: &self.commands) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._playerName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._artistName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._trackName) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._trackDuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.commands.isEmpty {
      try visitor.visitRepeatedEnumField(value: self.commands, fieldNumber: 1)
    }
    try { if let v = self._playerName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._artistName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._trackName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._trackDuration {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpHDMediaData, rhs: Protocol_PbPFtpHDMediaData) -> Bool {
    if lhs.commands != rhs.commands {return false}
    if lhs._playerName != rhs._playerName {return false}
    if lhs._artistName != rhs._artistName {return false}
    if lhs._trackName != rhs._trackName {return false}
    if lhs._trackDuration != rhs._trackDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_PbPFtpHDMediaControlPlaybackState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PbPFtpHDMediaControlPlaybackState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "playback_state"),
    2: .standard(proto: "playback_rate"),
    3: .standard(proto: "elapsed_time"),
    4: .standard(proto: "volume_level"),
  ]

  public var isInitialized: Bool {
    if self._playbackState == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._playbackState) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._playbackRate) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._elapsedTime) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._volumeLevel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._playbackState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._playbackRate {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._elapsedTime {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._volumeLevel {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Protocol_PbPFtpHDMediaControlPlaybackState, rhs: Protocol_PbPFtpHDMediaControlPlaybackState) -> Bool {
    if lhs._playbackState != rhs._playbackState {return false}
    if lhs._playbackRate != rhs._playbackRate {return false}
    if lhs._elapsedTime != rhs._elapsedTime {return false}
    if lhs._volumeLevel != rhs._volumeLevel {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
